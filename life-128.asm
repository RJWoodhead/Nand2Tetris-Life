//
// Conway's Game of Life in Hack Assembly language -- https://en.wikipedia.org/wiki/Conway's_Game_of_Life
//
// (C)2023 Robert Woodhead - trebor@animeigo.com / @madoverlord - Creative Commons Attribution License
//
// I am indebted to http://www.conwaylife.com/wiki/Main_Page, the LifeWiki, which is a great resource
// for finding interesting Life Patterns.
//
// Notes on implementation:
//
// Game Board: a 128x64 matrix of cells, wrapping around at the edges, so the board is effectively a torus.
// This maps onto the display screen with each cell taking up 4x4 pixels. The game board is stored as a
// 130x66 matrix with guard cells around the edges that are used to both simplify the code and implement
// the wrapping feature.
//
// Typical simple implementations of Life store multiple cells per word and use clever bit-banging techniques
// to update them in parallel to minimize the number of operations (especially memory fetches on machines
// where those are expensive). However, the Hack machine architecture is not well suited to these techniques
// so each cell is implemented as a full word; the sign bit contains the state of the cell in the current
// generation (so live = 1000 ... 0000 and dead = 0000 ... 0000). In the first pass, each cell has 1 added
// to it for each live neighbor. Then in a second pass, a table lookup is used to convert the neighbor count
// into the new value for the cell.
//
// Keyboard commands:
//
// 0-9		Load prestored board (0 = logo board)
// Space 	Compute Next Generation
// Return 	Free-run until another key pressed
// Arrows 	Move editing cursor up/down/right/left
// Q W E 	8-way cursor movement
// A   D
// Z X C
// ` or S 	Toggle current cell
// DEL 		Clear board
// < or ,	Push board into undo stack
// > or . 	Restore board from undo stack
//
// Note: HACK CPU emulator returns uppercase keyboard keys regardless of state of SHIFT or CAPSLOCK keys!

// Nomenclature Note:
//
// I put an identifying label at the start of each code segment or subroutine.
// Variables and labels defined inside that section of code all have names that
// are prefixed by the name of the code segment.
//
// So segment (SEG) will have labels like (SEG.Label) and variables like @SEG.x and @SEG.y.z.
//
// If the segment name is long, I will sometimes have a second shorter version of
// the naming label, so the sublabels and variable names can be shorter. IE:
//
// (Very.Long.Label.Name)
// (VLLN)
//
// 		@VLLN.xpos
//
// This makes it easier to find variables and labels in the symbol table generated by
// the assembler.

// Useful constants:

#Board_Rows=64											// Size of the life board
#Board_Cols=128
#Board_Size=(Board_Rows+2)*(Board_Cols+2)   			// Space required (including guard cells)
#Board_First_Cell=Board_Cols+3							// Offset of first actual cell (0,0)
#Board_Last_Cell=Board_Size-(Board_Cols+4)				// Offset of last actual cell (Board_Cols,Board_Rows)

#Compressed_Board_Size=(Board_Rows*Board_Cols)/16		// size of a compressed board
#Board_Words_Per_Row=Board_Cols/16						// # of words per row of compressed board
#Screen_Words_Per_Row=32								// # of words per scan line on the screen

// Key program variables:

$Life.x=64
$Life.y=32
$Life.key.repeat=0
$Life.blink=1
$Life.speed=32767

// Update tables for live and dead cells, giving new state for each number of neighbors.

$LiveTable(9)=0x0000,0x0000,0x8000,0x8000,0x0000,0x0000,0x0000,0x0000,0x0000
$DeadTable(9)=0x0000,0x0000,0x0000,0x8000,0x0000,0x0000,0x0000,0x0000,0x0000

// Divide-by-4 table.

$Div4(128)=0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,\
	11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,\
	19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,26,26,26,26,\
	27,27,27,27,28,28,28,28,29,29,29,29,30,30,30,30,31,31,31,31

// Table of bitmaps used to blink the cursor (4 cells per word in SCREEN memory).

$BlinkMask(4)=0b0000000000000110,0b0000000001100000,0b0000011000000000,0b0110000000000000

// Table of addresses of starting cells in each row.

$Board.Row(64)=Board+131,Board+261,Board+391,Board+521,Board+651,Board+781,Board+911,Board+1041,Board+1171,\
	Board+1301,Board+1431,Board+1561,Board+1691,Board+1821,Board+1951,Board+2081,Board+2211,Board+2341,\
	Board+2471,Board+2601,Board+2731,Board+2861,Board+2991,Board+3121,Board+3251,Board+3381,Board+3511,\
	Board+3641,Board+3771,Board+3901,Board+4031,Board+4161,Board+4291,Board+4421,Board+4551,Board+4681,\
	Board+4811,Board+4941,Board+5071,Board+5201,Board+5331,Board+5461,Board+5591,Board+5721,Board+5851,\
	Board+5981,Board+6111,Board+6241,Board+6371,Board+6501,Board+6631,Board+6761,Board+6891,Board+7021,\
	Board+7151,Board+7281,Board+7411,Board+7541,Board+7671,Board+7801,Board+7931,Board+8061,Board+8191,\
	Board+8321

// Board data storage.

$Board(Board_Size)

// Special value that lets us know we've reached the end of the board data. -1 is a value that can
// never be in the board data.

$BoardEndMark=-1

// We can have as many undo buffers as space permits. Boards are stored in the undo buffers as bitmaps,
// so we have to compress them when saving and can use the stored board load routine to restore them.

#Undo_Depth=4											// How many Undo buffers do we have?
#Undo_Size=Undo_Depth*Compressed_Board_Size				// Total size of the buffers
#Undo_Copy_Len=(Undo_Depth-1)*Compressed_Board_Size		// How much do we copy on a push or pop?

$Undo(Undo_Size)										// The buffers themselves

#Undo_Push_From=Undo+Undo_Copy_Len-1					// From/To copy locations for pushing a buffer;
#Undo_Push_To=Undo_Push_From+Compressed_Board_Size		// This copy proceeds backwards to start.

#Undo_Pop_From=Undo+Compressed_Board_Size				// Same for popping a buffer, but this copy
#Undo_Pop_To=Undo										// proceeds forwards.

// Stored boards. Boards are 128x64, so 8 words per row.

$Logo.png(*)=Boards/Logo.png
$Shimon.png(*)=Boards/Shimon.png
$Samples.png(*)=Boards/Samples.png
$NAND_11.png(*)=Boards/NAND_11.png
$NAND_10.png(*)=Boards/NAND_10.png
$NAND_01.png(*)=Boards/NAND_01.png
$NAND_00.png(*)=Boards/NAND_00.png

(START)

	@SCREEN 		// Initialize SP to SCREEN - 1
	D = A - 1
	@SP
	M = D

// Load the splash screen.

(Logo.Load)

	@Logo.Load.Ret	// D = return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Logo.png 		// D = Address of the compressed board image
	D = A

	@Load_Board 	// Load_Board()
	0 ; JMP

(Logo.Load.Ret)		// Return from Load_Board here

// All of our variables are initialized for us automatically by the assembler.

	@KBD 			// Life.key = [KBD]
	D = M
	@Life.key
	M = D

	@Key.Up 		// Skip to end of key processing loop if we have a key.
	D ; JNE 		// This handles issue of stale key on program start.

// Loop processing keys, blinking cursor while waiting.

(Key.Down) 			// Loop until key pressed

	@KBD 			// D = [KBD]
	D = M

	@Key.Pressed 	// if a key has been pressed, process it
	D ; JNE

	D = D 			// NOP instructions to slow down this loop
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D

	@Life.blink 	// if --Life.blink == 0, blink cursor
	MD = M - 1
	@Key.Down
	D ; JNE

// Blink the cursor

(Blink)

	@Life.speed 	// Life.blink = Life.speed (resets blink count)
	D = M
	@Life.blink
	M = D

// Compute the location in the screen buffer of the current cursor position.
// There are 32 bytes per row, and 4 rows per cell. 32*8 = 128. We also skip
// a row because we only modify the central 2x2 pixels of a cell. We could
// use a table for *128 but speed isn't needed here.

	@Life.y 		// Blink.row = (Life.y * 128) + SCREEN + 32
	AD = M          // we can get a little clever here by storing the results
	AD = D + A      // in both A and D, and then adding them together.
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	@SCREEN+32      // Skip the first row
	D = D + A
	@Blink.row
	M = D

// Each word in the screen buffer holds the bits for two adjacent cells.
// Do a table lookup to get the desired bitmap.

	@0x0003			// D = the low two bits of Life.x
	D = A			
	@Life.x
	D = D & M
	@BlinkMask		// D = BlinkMask[D]
	A = D + A
	D = M

	@Blink.mask 	// Blink.mask = XOR mask of bits to flip
	M = D

	@Life.x 		// Blink.row = Blink.row + Div.4[Life.x]
	D = M 			// Since we don't have a shift-right instruction
	@Div4 			// we use a lookup table
	A = D + A
	D = M

	@Blink.row 		// Also save Blink.row in A, so M then points to the
	AM = D + M 		// first word in screem memory we want to alter

	D = M 			// Blink.word = [Blink.row]
	@Blink.word
	M = D

	@Blink.mask 	// Blink.new = Blink.word XOR Blink.mask
	D = D | M 		// XOR(A,B) = (A|B) & !(A&B)
	@Blink.or
	M = D

	@Blink.word
	D = M
	@Blink.mask
	D = D & M
	D = !D

	@Blink.or
	D = D & M

	@Blink.new
	M = D

	@Blink.row 		// [Blink.row] = Blink.new
	A = M
	M = D

	@Blink.row 		// [Blink.row += 32] = Blink.new
	D = M
	@Screen_Words_Per_Row
	D = D + A
	@Blink.row
	M = D

	@Blink.new
	D = M

	@Blink.row
	A = M
	M = D

	@Key.Down 		// Resume looking for a key
	0 ; JMP

// Decode keypresses.

(Key.Pressed)

	@Life.key 		// @Life.key = D
	M = D

	// Arrow keys

	@Life.key 		// Up
	D = M
	@KBD_UPARROW
	D = D - A
	@Key.MoveUp
	D ; JEQ

	@Life.key 		// Down
	D = M
	@KBD_DOWNARROW
	D = D - A
	@Key.MoveDown
	D ; JEQ

	@Life.key 		// Right
	D = M
	@KBD_RIGHTARROW
	D = D - A
	@Key.MoveRight
	D ; JEQ

	@Life.key 		// Left
	D = M
	@KBD_LEFTARROW
	D = D - A
	@Key.MoveLeft
	D ; JEQ

	// 8-way keys

	@Life.key 		// W = Up
	D = M
	@"W"
	D = D - A
	@Key.MoveUp
	D ; JEQ

	@Life.key 		// X = Down
	D = M
	@"X"
	D = D - A
	@Key.MoveDown
	D ; JEQ

	@Life.key 		// D = Right
	D = M
	@"D"
	D = D - A
	@Key.MoveRight
	D ; JEQ

	@Life.key 		// A = Left
	D = M
	@"A"
	D = D - A
	@Key.MoveLeft
	D ; JEQ

	@Life.key 		// Q = Up-Left
	D = M
	@"Q"
	D = D - A
	@Key.MoveUpLeft
	D ; JEQ

	@Life.key 		// E = Up-Right
	D = M
	@"E"
	D = D - A
	@Key.MoveUpRight
	D ; JEQ

	@Life.key 		// Z = Down-Left
	D = M
	@"Z"
	D = D - A
	@Key.MoveDownLeft
	D ; JEQ

	@Life.key 		// C = Down-Right
	D = M
	@"C"
	D = D - A
	@Key.MoveDownRight
	D ; JEQ

	@Life.key 		// Space bar (single generation)
	D = M
	@KBD_SPACE 			
	D = D - A
	@Key.Space 			
	D ; JEQ

	@Life.key 		// Enter (free run)
	D = M
	@KBD_NEWLINE
	D = D - A
	@Key.Enter
	D ; JEQ

	@Life.key 		// DEL
	D = M
	@KBD_BACKSPACE
	D = D - A
	@Key.Clear
	D ; JEQ

	@Life.key 		// ` = Toggle cell
	D = M
	@96
	D = D - A
	@Key.Toggle
	D ; JEQ

	@Life.key 		// S = Toggle cell
	D = M
	@"S"
	D = D - A
	@Key.Toggle
	D ; JEQ

	@Life.key		// < = Push into undo buffer
	D = M
	@"<"
	D = D - A
	@Key.Push
	D ; JEQ
	
	@Life.key		// Alternate key.
	D = M
	@","
	D = D - A
	@Key.Push
	D ; JEQ
	
	@Life.key		// < = Pop from undo buffer
	D = M
	@">"
	D = D - A
	@Key.Pop
	D ; JEQ
	
	@Life.key		// Alternate key.
	D = M
	@"."
	D = D - A
	@Key.Pop
	D ; JEQ

// Last thing we check is loading prestored patterns. First, we
// prepare for an eventual function call to Load_Board(), with
// a direct return to the end of our keyboard handler.

	@Key.Up
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	// Next, we look for a pattern key and set the D register with the
	// address of the board. The simple way is to subtract "0" from
    // the key, and then keep decrementing it until we get a 0 result
    // (or fall off the end).

	@Life.key
	D = M
	@"0"
	D = D - A

	@Key.Pattern0
	D ; JEQ

	D = D - 1
	@Key.Pattern1
	D ; JEQ

	D = D - 1
	@Key.Pattern2
	D ; JEQ

	D = D - 1
	@Key.Pattern3
	D ; JEQ

	D = D - 1
	@Key.Pattern4
	D ; JEQ

	D = D - 1
	@Key.Pattern5
	D ; JEQ

	D = D - 1
	@Key.Pattern6
	D ; JEQ

	D = D - 1
	@Key.Pattern7
	D ; JEQ

	D = D - 1
	@Key.Pattern8
	D ; JEQ

	D = D - 1
	@Key.Pattern9
	D ; JEQ

// Room for more patterns if and when needed...

(Key.Pattern7)
(Key.Pattern8)
(Key.Pattern9)

// If we get to here, we don't have a valid board, so we need
// to restore the SP.

	@SP 			// Pop the un-needed return address off stack
	M = M + 1

	@Key.Up 		// And skip to the bottom of the handler
	0 ; JMP

// Individual handlers for each stored pattern. They just set D
// to the address of the pattern and jump to Load_Board.

(Key.Pattern0)
	
	@Logo.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern1)

	@Samples.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern2)

	@Shimon.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern3)

	@NAND_11.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern4)

	@NAND_01.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern5)

	@NAND_10.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern6)

	@NAND_00.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

// Space bar - run a generation.

(Key.Space)

	@Key.Space.Ret	// D = Generation return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Generation 	// Generation()
	0 ; JMP

(Key.Space.Ret)

	@Key.Up
	0 ; JMP

// C - clear the board.

(Key.Clear)

	@Key.Change		// D = return directly to Key.Change handler below
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Clear_Board 	// Clear_Board()
	0 ; JMP

// < - Push the current board. First, we shift down the current boards
// in the Undo buffer (proceeding from bottom upwards so as not to smash
// stuff before it gets copied), and then we compress the board and
// store it at the top of the buffer.

(Key.Push)

	@Undo_Copy_Len		// Undo.Count = # of words to copy
	D = A
	@Undo.Count
	M = D

	@Undo_Push_From		// Undo.From = Undo
	D = A
	@Undo.From
	M = D

	@Undo_Push_To		// Undo.To = Undo2
	D = A
	@Undo.To
	M = D

(Key.Push.Loop)

	@Undo.From			// [Undo.To] = [Undo.From]
	A = M
	D = M
	@Undo.To
	A = M
	M = D

	@Undo.From			// Undo.From--
	M = M - 1

	@Undo.To			// Undo.To--
	M = M - 1

	@Undo.Count			// Undo.Count--, also copy result to D
	MD = M - 1

	@Key.Push.Loop		// Loop if we have more to do
	D ; JNE

	@Key.Change 		// Call Save_Board(), return direct to end of keyboard handler
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Undo					// D = Undo Buffer location
	D = A
	@Save_Board				// Save_Board()
	0 ; JMP

// > - Restore the board. This time we load the top board in the
// Undo buffer, then move everything else up. Note that in this
// case the direction of copy is opposite to the push case.

(Key.Pop)

	@Key.Pop.Ret		// D = return address
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Undo 				// D = Address of the compressed board image
	D = A

	@Load_Board 		// Load_Board()
	0 ; JMP

(Key.Pop.Ret)

	@Undo_Copy_Len		// Undo.Count = # of words to copy
	D = A
	@Undo.Count
	M = D

	@Undo_Pop_From		// Undo.From = Source
	D = A
	@Undo.From
	M = D

	@Undo_Pop_To		// Undo.To = Destination
	D = A
	@Undo.To
	M = D

(Key.Pop.Loop)

	@Undo.From			// [Undo.To] = [Undo.From]
	A = M
	D = M
	@Undo.To
	A = M
	M = D

	@Undo.From			// Undo.From++
	M = M + 1

	@Undo.To			// Undo.To++
	M = M + 1

	@Undo.Count			// Undo.Count--, also copy result to D
	MD = M - 1

	@Key.Pop.Loop		// Loop if we have more to do
	D ; JNE

	@Key.Change 			// Done
	0 ; JMP

// In all the cursor routines, we use a bitmask to keep the x,y position in bounds.
// This only works if the bounds are a power of 2. If we are moving diagonally,
// we can move in one direction and then fall through to the code that moves
// in the other direction.

// UpLeft - move cursor.

(Key.MoveUpLeft)

	@Board_Cols-1	// Move left, then fall through to move up
	D = A
	@Life.x
	M = M - 1
	M = D & M

// Up - move cursor.

(Key.MoveUp)

	@Board_Rows-1
	D = A
	@Life.y
	M = M - 1
	M = D & M

	@Key.Change
	0 ; JMP

// DownRight - move cursor.

(Key.MoveDownRight)

	@Board_Cols-1
	D = A
	@Life.x
	M = M + 1
	M = D & M

// Down - move cursor.

(Key.MoveDown)

	@Board_Rows-1
	D = A
	@Life.y
	M = M + 1
	M = D & M

	@Key.Change
	0 ; JMP

// DownLeft - move cursor.

(Key.MoveDownLeft)

	@Board_Rows-1
	D = A
	@Life.y
	M = M + 1
	M = D & M

// Left - move cursor.

(Key.MoveLeft)

	@Board_Cols-1
	D = A
	@Life.x
	M = M - 1
	M = D & M

	@Key.Change
	0 ; JMP

// UpRight - move cursor.

(Key.MoveUpRight)

	@Board_Rows-1
	D = A
	@Life.y
	M = M - 1
	M = D & M

// Right - move cursor.

(Key.MoveRight)

	@Board_Cols-1
	D = A
	@Life.x
	M = M + 1
	M = D & M

	@Key.Change
	0 ; JMP

// Toggle current cell.

(Key.Toggle)

	@Life.y         // Cell Address = Board.Row[Life.y] + Life.x
	D = M
	@Board.Row
	A = A + D
    D = M

 	@Life.x         // Add in X value to get the address
	D = D + M       // of the cell we want to toggle

    @Cur.Cell       // Save it for later and move to
    AM = D          // A register so we can look at it

    D = M           // Get value of cell

    @Key.Toggle.Dead  // If dead, make alive, and vice-versa
    D ; JEQ

(Key.Toggle.Alive)

    D = 0           // Dead = 0
    @Cur.Cell       // Address of current cell
    A = M
    M = D           // Update value
	@Key.Change     // And return
	0 ; JMP

(Key.Toggle.Dead)

    @0x4000         // Alive = 0x8000, but we can't load that value
    D = A           // so we load 0x4000 and add it twice
    D = D + A
    @Cur.Cell       // Address of current cell
    A = M
    M = D           // Update value
	@Key.Change     // And return
	0 ; JMP

// Enter - run generations until another key pressed.

(Key.Enter)

	@Key.Enter.Ret	// D = Generation return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Generation 	// Generation()
	0 ; JMP

(Key.Enter.Ret)

	@KBD 			// Do another generation if KBD == Life.key (either 128 or 0)
	D = M
	@Life.key
	D = D - M
	@Key.Enter
	D ; JEQ

	@Life.key 		// Reset the current key (so we will catch "no key" just above, but now Enter will stop us)
	M = 0

	@KBD 			// If no key, we can loop
	D = M
	@Key.Enter
	D ; JEQ

	@Life.key 		// Restore Life.key to current key, so it'll be debounced below
	M = D

	@Key.Up 		// Terminate looping
	0 ; JMP

// Handle changes in state by repainting the screen (and jump to Key.Up handler on return).

(Key.Change)

	@Key.Up			// D = return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Paint_Board 	// Paint_Board()
	0 ; JMP

// Bottom of key processing loop.

(Key.Up)			// Loop until KBD no longer Life.key (either new key or key up)

	@Life.key
	D = M
	@KBD
	D = D - M
	@Key.Up
	D ; JEQ

	@Key.Down 		// Return to checking for new key
	0 ; JMP

// End of program infinite loop, not actually reachable but all programs are
// supposed to have one, so...

	@DONE
(DONE)
	0 ; JMP

// Generation: runs a single generation of Life, then updates the board display.

(Generation)

	// Phase 1: for each living cell (not counting the guard cells), increment all
	// the neighbors, so they have a count of how many neighbors they have. Note that
	// we can plow through all the guard cells on left and right because they will
	// always be dead, and it's faster to do this than do a double-loop with skip.

	@Board+Board_First_Cell	// G.cell = Address of the first real cell
	D = A
	@G.cell
	M = D

(G.1.Top) 					// repeat check_cell until ++G.cell == Board+8449 (1 past last cell)

	@G.cell 				// if [G.cell] >= 0, skip to bottom of loop (it's dead)
	A = M
	D = M
	@G.1.Bottom
	D ; JGE

	@G.cell 				// A=[G.cell]-(Board_Cols+3) (top-left neighbor)
	D = M
	@Board_Cols+3
	A = D - A
	M = M + 1				// [A]++

	A = A + 1 				// [++A]++ (top neighbor)
	M = M + 1

	A = A + 1 				// [++A]++ (top-right neighbor)
	M = M + 1

	D = A 					// A=A+Board_Cols (left neighbor)
	@Board_Cols
	A = D + A
	M = M + 1				// [A]++

	A = A + 1 				// A=A+2 (right neighbor)
	A = A + 1
	M = M + 1				// [A]++

	D = A 					// A=A+Board_Cols (bottom-left neighbor)
	@Board_Cols
	A = D + A
	M = M + 1

	A = A + 1 				// [++A]++ (bottom neighbor)
	M = M + 1

	A = A + 1 				// [++A]++ (bottom-right neighbor)
	M = M + 1

(G.1.Bottom)

// Optimization to speed up the loop. Normally we would just check to see if G.cell has
// passed the last actual cell in the board. This takes 6 instructions as follows:
//
//  @G.cell 					// D,G.cell = G.cell + 1
//  MD = M + 1
//	@Board+Board_Last_Cell+1 	// if (G.cell != First Guard Cell after board) goto G.1.Top
//	D = D - A
//	@G.1.Top
//	D ; JNE
//
// However, by having a cell with an impossible but easy-to-test value (-1), we can shave
// off one instruction, at the cost of running the loop for Board_Cols+2 extra iterations.
// Each iteration is 10 instructions, so it's a win if there are more than 10 rows in our
// board, which there certainly are!

	@G.cell 					// A,G.cell = G.cell + 1
	AM = M + 1
	D = M + 1					// if the special guard cell is -1, then D will now be 0
	@G.1.Top					// so if D != 0, we are not done.
	D ; JNE

	// Phase 2: add the counts in the guard cells to their respective border cells
	// on the opposite edge, and clear the guard cells. Here is a map of the guard
	// cells and the edge cells
	//
	// 0000 0001 ..... 0128 0129
	// 0130 0131 ..... 0258 0259
	//   .    .          .    .
	//   .    .          .    .
	// 8320 8321 ..... 8448 8449
	// 8450 8451 ..... 8578 8579
	//
	// The following code was auto-generated by tables-128.py. This is a case where
	// unrolling the loops is a big win because we don't have to do address arithmetic.

	@Board+0
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+129
	D = M
	M = 0
	@Board+8321
	M = M + D

	@Board+8450
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+8579
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+1
	D = M
	M = 0
	@Board+8321
	M = M + D

	@Board+8451
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+2
	D = M
	M = 0
	@Board+8322
	M = M + D

	@Board+8452
	D = M
	M = 0
	@Board+132
	M = M + D

	@Board+3
	D = M
	M = 0
	@Board+8323
	M = M + D

	@Board+8453
	D = M
	M = 0
	@Board+133
	M = M + D

	@Board+4
	D = M
	M = 0
	@Board+8324
	M = M + D

	@Board+8454
	D = M
	M = 0
	@Board+134
	M = M + D

	@Board+5
	D = M
	M = 0
	@Board+8325
	M = M + D

	@Board+8455
	D = M
	M = 0
	@Board+135
	M = M + D

	@Board+6
	D = M
	M = 0
	@Board+8326
	M = M + D

	@Board+8456
	D = M
	M = 0
	@Board+136
	M = M + D

	@Board+7
	D = M
	M = 0
	@Board+8327
	M = M + D

	@Board+8457
	D = M
	M = 0
	@Board+137
	M = M + D

	@Board+8
	D = M
	M = 0
	@Board+8328
	M = M + D

	@Board+8458
	D = M
	M = 0
	@Board+138
	M = M + D

	@Board+9
	D = M
	M = 0
	@Board+8329
	M = M + D

	@Board+8459
	D = M
	M = 0
	@Board+139
	M = M + D

	@Board+10
	D = M
	M = 0
	@Board+8330
	M = M + D

	@Board+8460
	D = M
	M = 0
	@Board+140
	M = M + D

	@Board+11
	D = M
	M = 0
	@Board+8331
	M = M + D

	@Board+8461
	D = M
	M = 0
	@Board+141
	M = M + D

	@Board+12
	D = M
	M = 0
	@Board+8332
	M = M + D

	@Board+8462
	D = M
	M = 0
	@Board+142
	M = M + D

	@Board+13
	D = M
	M = 0
	@Board+8333
	M = M + D

	@Board+8463
	D = M
	M = 0
	@Board+143
	M = M + D

	@Board+14
	D = M
	M = 0
	@Board+8334
	M = M + D

	@Board+8464
	D = M
	M = 0
	@Board+144
	M = M + D

	@Board+15
	D = M
	M = 0
	@Board+8335
	M = M + D

	@Board+8465
	D = M
	M = 0
	@Board+145
	M = M + D

	@Board+16
	D = M
	M = 0
	@Board+8336
	M = M + D

	@Board+8466
	D = M
	M = 0
	@Board+146
	M = M + D

	@Board+17
	D = M
	M = 0
	@Board+8337
	M = M + D

	@Board+8467
	D = M
	M = 0
	@Board+147
	M = M + D

	@Board+18
	D = M
	M = 0
	@Board+8338
	M = M + D

	@Board+8468
	D = M
	M = 0
	@Board+148
	M = M + D

	@Board+19
	D = M
	M = 0
	@Board+8339
	M = M + D

	@Board+8469
	D = M
	M = 0
	@Board+149
	M = M + D

	@Board+20
	D = M
	M = 0
	@Board+8340
	M = M + D

	@Board+8470
	D = M
	M = 0
	@Board+150
	M = M + D

	@Board+21
	D = M
	M = 0
	@Board+8341
	M = M + D

	@Board+8471
	D = M
	M = 0
	@Board+151
	M = M + D

	@Board+22
	D = M
	M = 0
	@Board+8342
	M = M + D

	@Board+8472
	D = M
	M = 0
	@Board+152
	M = M + D

	@Board+23
	D = M
	M = 0
	@Board+8343
	M = M + D

	@Board+8473
	D = M
	M = 0
	@Board+153
	M = M + D

	@Board+24
	D = M
	M = 0
	@Board+8344
	M = M + D

	@Board+8474
	D = M
	M = 0
	@Board+154
	M = M + D

	@Board+25
	D = M
	M = 0
	@Board+8345
	M = M + D

	@Board+8475
	D = M
	M = 0
	@Board+155
	M = M + D

	@Board+26
	D = M
	M = 0
	@Board+8346
	M = M + D

	@Board+8476
	D = M
	M = 0
	@Board+156
	M = M + D

	@Board+27
	D = M
	M = 0
	@Board+8347
	M = M + D

	@Board+8477
	D = M
	M = 0
	@Board+157
	M = M + D

	@Board+28
	D = M
	M = 0
	@Board+8348
	M = M + D

	@Board+8478
	D = M
	M = 0
	@Board+158
	M = M + D

	@Board+29
	D = M
	M = 0
	@Board+8349
	M = M + D

	@Board+8479
	D = M
	M = 0
	@Board+159
	M = M + D

	@Board+30
	D = M
	M = 0
	@Board+8350
	M = M + D

	@Board+8480
	D = M
	M = 0
	@Board+160
	M = M + D

	@Board+31
	D = M
	M = 0
	@Board+8351
	M = M + D

	@Board+8481
	D = M
	M = 0
	@Board+161
	M = M + D

	@Board+32
	D = M
	M = 0
	@Board+8352
	M = M + D

	@Board+8482
	D = M
	M = 0
	@Board+162
	M = M + D

	@Board+33
	D = M
	M = 0
	@Board+8353
	M = M + D

	@Board+8483
	D = M
	M = 0
	@Board+163
	M = M + D

	@Board+34
	D = M
	M = 0
	@Board+8354
	M = M + D

	@Board+8484
	D = M
	M = 0
	@Board+164
	M = M + D

	@Board+35
	D = M
	M = 0
	@Board+8355
	M = M + D

	@Board+8485
	D = M
	M = 0
	@Board+165
	M = M + D

	@Board+36
	D = M
	M = 0
	@Board+8356
	M = M + D

	@Board+8486
	D = M
	M = 0
	@Board+166
	M = M + D

	@Board+37
	D = M
	M = 0
	@Board+8357
	M = M + D

	@Board+8487
	D = M
	M = 0
	@Board+167
	M = M + D

	@Board+38
	D = M
	M = 0
	@Board+8358
	M = M + D

	@Board+8488
	D = M
	M = 0
	@Board+168
	M = M + D

	@Board+39
	D = M
	M = 0
	@Board+8359
	M = M + D

	@Board+8489
	D = M
	M = 0
	@Board+169
	M = M + D

	@Board+40
	D = M
	M = 0
	@Board+8360
	M = M + D

	@Board+8490
	D = M
	M = 0
	@Board+170
	M = M + D

	@Board+41
	D = M
	M = 0
	@Board+8361
	M = M + D

	@Board+8491
	D = M
	M = 0
	@Board+171
	M = M + D

	@Board+42
	D = M
	M = 0
	@Board+8362
	M = M + D

	@Board+8492
	D = M
	M = 0
	@Board+172
	M = M + D

	@Board+43
	D = M
	M = 0
	@Board+8363
	M = M + D

	@Board+8493
	D = M
	M = 0
	@Board+173
	M = M + D

	@Board+44
	D = M
	M = 0
	@Board+8364
	M = M + D

	@Board+8494
	D = M
	M = 0
	@Board+174
	M = M + D

	@Board+45
	D = M
	M = 0
	@Board+8365
	M = M + D

	@Board+8495
	D = M
	M = 0
	@Board+175
	M = M + D

	@Board+46
	D = M
	M = 0
	@Board+8366
	M = M + D

	@Board+8496
	D = M
	M = 0
	@Board+176
	M = M + D

	@Board+47
	D = M
	M = 0
	@Board+8367
	M = M + D

	@Board+8497
	D = M
	M = 0
	@Board+177
	M = M + D

	@Board+48
	D = M
	M = 0
	@Board+8368
	M = M + D

	@Board+8498
	D = M
	M = 0
	@Board+178
	M = M + D

	@Board+49
	D = M
	M = 0
	@Board+8369
	M = M + D

	@Board+8499
	D = M
	M = 0
	@Board+179
	M = M + D

	@Board+50
	D = M
	M = 0
	@Board+8370
	M = M + D

	@Board+8500
	D = M
	M = 0
	@Board+180
	M = M + D

	@Board+51
	D = M
	M = 0
	@Board+8371
	M = M + D

	@Board+8501
	D = M
	M = 0
	@Board+181
	M = M + D

	@Board+52
	D = M
	M = 0
	@Board+8372
	M = M + D

	@Board+8502
	D = M
	M = 0
	@Board+182
	M = M + D

	@Board+53
	D = M
	M = 0
	@Board+8373
	M = M + D

	@Board+8503
	D = M
	M = 0
	@Board+183
	M = M + D

	@Board+54
	D = M
	M = 0
	@Board+8374
	M = M + D

	@Board+8504
	D = M
	M = 0
	@Board+184
	M = M + D

	@Board+55
	D = M
	M = 0
	@Board+8375
	M = M + D

	@Board+8505
	D = M
	M = 0
	@Board+185
	M = M + D

	@Board+56
	D = M
	M = 0
	@Board+8376
	M = M + D

	@Board+8506
	D = M
	M = 0
	@Board+186
	M = M + D

	@Board+57
	D = M
	M = 0
	@Board+8377
	M = M + D

	@Board+8507
	D = M
	M = 0
	@Board+187
	M = M + D

	@Board+58
	D = M
	M = 0
	@Board+8378
	M = M + D

	@Board+8508
	D = M
	M = 0
	@Board+188
	M = M + D

	@Board+59
	D = M
	M = 0
	@Board+8379
	M = M + D

	@Board+8509
	D = M
	M = 0
	@Board+189
	M = M + D

	@Board+60
	D = M
	M = 0
	@Board+8380
	M = M + D

	@Board+8510
	D = M
	M = 0
	@Board+190
	M = M + D

	@Board+61
	D = M
	M = 0
	@Board+8381
	M = M + D

	@Board+8511
	D = M
	M = 0
	@Board+191
	M = M + D

	@Board+62
	D = M
	M = 0
	@Board+8382
	M = M + D

	@Board+8512
	D = M
	M = 0
	@Board+192
	M = M + D

	@Board+63
	D = M
	M = 0
	@Board+8383
	M = M + D

	@Board+8513
	D = M
	M = 0
	@Board+193
	M = M + D

	@Board+64
	D = M
	M = 0
	@Board+8384
	M = M + D

	@Board+8514
	D = M
	M = 0
	@Board+194
	M = M + D

	@Board+65
	D = M
	M = 0
	@Board+8385
	M = M + D

	@Board+8515
	D = M
	M = 0
	@Board+195
	M = M + D

	@Board+66
	D = M
	M = 0
	@Board+8386
	M = M + D

	@Board+8516
	D = M
	M = 0
	@Board+196
	M = M + D

	@Board+67
	D = M
	M = 0
	@Board+8387
	M = M + D

	@Board+8517
	D = M
	M = 0
	@Board+197
	M = M + D

	@Board+68
	D = M
	M = 0
	@Board+8388
	M = M + D

	@Board+8518
	D = M
	M = 0
	@Board+198
	M = M + D

	@Board+69
	D = M
	M = 0
	@Board+8389
	M = M + D

	@Board+8519
	D = M
	M = 0
	@Board+199
	M = M + D

	@Board+70
	D = M
	M = 0
	@Board+8390
	M = M + D

	@Board+8520
	D = M
	M = 0
	@Board+200
	M = M + D

	@Board+71
	D = M
	M = 0
	@Board+8391
	M = M + D

	@Board+8521
	D = M
	M = 0
	@Board+201
	M = M + D

	@Board+72
	D = M
	M = 0
	@Board+8392
	M = M + D

	@Board+8522
	D = M
	M = 0
	@Board+202
	M = M + D

	@Board+73
	D = M
	M = 0
	@Board+8393
	M = M + D

	@Board+8523
	D = M
	M = 0
	@Board+203
	M = M + D

	@Board+74
	D = M
	M = 0
	@Board+8394
	M = M + D

	@Board+8524
	D = M
	M = 0
	@Board+204
	M = M + D

	@Board+75
	D = M
	M = 0
	@Board+8395
	M = M + D

	@Board+8525
	D = M
	M = 0
	@Board+205
	M = M + D

	@Board+76
	D = M
	M = 0
	@Board+8396
	M = M + D

	@Board+8526
	D = M
	M = 0
	@Board+206
	M = M + D

	@Board+77
	D = M
	M = 0
	@Board+8397
	M = M + D

	@Board+8527
	D = M
	M = 0
	@Board+207
	M = M + D

	@Board+78
	D = M
	M = 0
	@Board+8398
	M = M + D

	@Board+8528
	D = M
	M = 0
	@Board+208
	M = M + D

	@Board+79
	D = M
	M = 0
	@Board+8399
	M = M + D

	@Board+8529
	D = M
	M = 0
	@Board+209
	M = M + D

	@Board+80
	D = M
	M = 0
	@Board+8400
	M = M + D

	@Board+8530
	D = M
	M = 0
	@Board+210
	M = M + D

	@Board+81
	D = M
	M = 0
	@Board+8401
	M = M + D

	@Board+8531
	D = M
	M = 0
	@Board+211
	M = M + D

	@Board+82
	D = M
	M = 0
	@Board+8402
	M = M + D

	@Board+8532
	D = M
	M = 0
	@Board+212
	M = M + D

	@Board+83
	D = M
	M = 0
	@Board+8403
	M = M + D

	@Board+8533
	D = M
	M = 0
	@Board+213
	M = M + D

	@Board+84
	D = M
	M = 0
	@Board+8404
	M = M + D

	@Board+8534
	D = M
	M = 0
	@Board+214
	M = M + D

	@Board+85
	D = M
	M = 0
	@Board+8405
	M = M + D

	@Board+8535
	D = M
	M = 0
	@Board+215
	M = M + D

	@Board+86
	D = M
	M = 0
	@Board+8406
	M = M + D

	@Board+8536
	D = M
	M = 0
	@Board+216
	M = M + D

	@Board+87
	D = M
	M = 0
	@Board+8407
	M = M + D

	@Board+8537
	D = M
	M = 0
	@Board+217
	M = M + D

	@Board+88
	D = M
	M = 0
	@Board+8408
	M = M + D

	@Board+8538
	D = M
	M = 0
	@Board+218
	M = M + D

	@Board+89
	D = M
	M = 0
	@Board+8409
	M = M + D

	@Board+8539
	D = M
	M = 0
	@Board+219
	M = M + D

	@Board+90
	D = M
	M = 0
	@Board+8410
	M = M + D

	@Board+8540
	D = M
	M = 0
	@Board+220
	M = M + D

	@Board+91
	D = M
	M = 0
	@Board+8411
	M = M + D

	@Board+8541
	D = M
	M = 0
	@Board+221
	M = M + D

	@Board+92
	D = M
	M = 0
	@Board+8412
	M = M + D

	@Board+8542
	D = M
	M = 0
	@Board+222
	M = M + D

	@Board+93
	D = M
	M = 0
	@Board+8413
	M = M + D

	@Board+8543
	D = M
	M = 0
	@Board+223
	M = M + D

	@Board+94
	D = M
	M = 0
	@Board+8414
	M = M + D

	@Board+8544
	D = M
	M = 0
	@Board+224
	M = M + D

	@Board+95
	D = M
	M = 0
	@Board+8415
	M = M + D

	@Board+8545
	D = M
	M = 0
	@Board+225
	M = M + D

	@Board+96
	D = M
	M = 0
	@Board+8416
	M = M + D

	@Board+8546
	D = M
	M = 0
	@Board+226
	M = M + D

	@Board+97
	D = M
	M = 0
	@Board+8417
	M = M + D

	@Board+8547
	D = M
	M = 0
	@Board+227
	M = M + D

	@Board+98
	D = M
	M = 0
	@Board+8418
	M = M + D

	@Board+8548
	D = M
	M = 0
	@Board+228
	M = M + D

	@Board+99
	D = M
	M = 0
	@Board+8419
	M = M + D

	@Board+8549
	D = M
	M = 0
	@Board+229
	M = M + D

	@Board+100
	D = M
	M = 0
	@Board+8420
	M = M + D

	@Board+8550
	D = M
	M = 0
	@Board+230
	M = M + D

	@Board+101
	D = M
	M = 0
	@Board+8421
	M = M + D

	@Board+8551
	D = M
	M = 0
	@Board+231
	M = M + D

	@Board+102
	D = M
	M = 0
	@Board+8422
	M = M + D

	@Board+8552
	D = M
	M = 0
	@Board+232
	M = M + D

	@Board+103
	D = M
	M = 0
	@Board+8423
	M = M + D

	@Board+8553
	D = M
	M = 0
	@Board+233
	M = M + D

	@Board+104
	D = M
	M = 0
	@Board+8424
	M = M + D

	@Board+8554
	D = M
	M = 0
	@Board+234
	M = M + D

	@Board+105
	D = M
	M = 0
	@Board+8425
	M = M + D

	@Board+8555
	D = M
	M = 0
	@Board+235
	M = M + D

	@Board+106
	D = M
	M = 0
	@Board+8426
	M = M + D

	@Board+8556
	D = M
	M = 0
	@Board+236
	M = M + D

	@Board+107
	D = M
	M = 0
	@Board+8427
	M = M + D

	@Board+8557
	D = M
	M = 0
	@Board+237
	M = M + D

	@Board+108
	D = M
	M = 0
	@Board+8428
	M = M + D

	@Board+8558
	D = M
	M = 0
	@Board+238
	M = M + D

	@Board+109
	D = M
	M = 0
	@Board+8429
	M = M + D

	@Board+8559
	D = M
	M = 0
	@Board+239
	M = M + D

	@Board+110
	D = M
	M = 0
	@Board+8430
	M = M + D

	@Board+8560
	D = M
	M = 0
	@Board+240
	M = M + D

	@Board+111
	D = M
	M = 0
	@Board+8431
	M = M + D

	@Board+8561
	D = M
	M = 0
	@Board+241
	M = M + D

	@Board+112
	D = M
	M = 0
	@Board+8432
	M = M + D

	@Board+8562
	D = M
	M = 0
	@Board+242
	M = M + D

	@Board+113
	D = M
	M = 0
	@Board+8433
	M = M + D

	@Board+8563
	D = M
	M = 0
	@Board+243
	M = M + D

	@Board+114
	D = M
	M = 0
	@Board+8434
	M = M + D

	@Board+8564
	D = M
	M = 0
	@Board+244
	M = M + D

	@Board+115
	D = M
	M = 0
	@Board+8435
	M = M + D

	@Board+8565
	D = M
	M = 0
	@Board+245
	M = M + D

	@Board+116
	D = M
	M = 0
	@Board+8436
	M = M + D

	@Board+8566
	D = M
	M = 0
	@Board+246
	M = M + D

	@Board+117
	D = M
	M = 0
	@Board+8437
	M = M + D

	@Board+8567
	D = M
	M = 0
	@Board+247
	M = M + D

	@Board+118
	D = M
	M = 0
	@Board+8438
	M = M + D

	@Board+8568
	D = M
	M = 0
	@Board+248
	M = M + D

	@Board+119
	D = M
	M = 0
	@Board+8439
	M = M + D

	@Board+8569
	D = M
	M = 0
	@Board+249
	M = M + D

	@Board+120
	D = M
	M = 0
	@Board+8440
	M = M + D

	@Board+8570
	D = M
	M = 0
	@Board+250
	M = M + D

	@Board+121
	D = M
	M = 0
	@Board+8441
	M = M + D

	@Board+8571
	D = M
	M = 0
	@Board+251
	M = M + D

	@Board+122
	D = M
	M = 0
	@Board+8442
	M = M + D

	@Board+8572
	D = M
	M = 0
	@Board+252
	M = M + D

	@Board+123
	D = M
	M = 0
	@Board+8443
	M = M + D

	@Board+8573
	D = M
	M = 0
	@Board+253
	M = M + D

	@Board+124
	D = M
	M = 0
	@Board+8444
	M = M + D

	@Board+8574
	D = M
	M = 0
	@Board+254
	M = M + D

	@Board+125
	D = M
	M = 0
	@Board+8445
	M = M + D

	@Board+8575
	D = M
	M = 0
	@Board+255
	M = M + D

	@Board+126
	D = M
	M = 0
	@Board+8446
	M = M + D

	@Board+8576
	D = M
	M = 0
	@Board+256
	M = M + D

	@Board+127
	D = M
	M = 0
	@Board+8447
	M = M + D

	@Board+8577
	D = M
	M = 0
	@Board+257
	M = M + D

	@Board+128
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+8578
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+130
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+259
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+260
	D = M
	M = 0
	@Board+388
	M = M + D

	@Board+389
	D = M
	M = 0
	@Board+261
	M = M + D

	@Board+390
	D = M
	M = 0
	@Board+518
	M = M + D

	@Board+519
	D = M
	M = 0
	@Board+391
	M = M + D

	@Board+520
	D = M
	M = 0
	@Board+648
	M = M + D

	@Board+649
	D = M
	M = 0
	@Board+521
	M = M + D

	@Board+650
	D = M
	M = 0
	@Board+778
	M = M + D

	@Board+779
	D = M
	M = 0
	@Board+651
	M = M + D

	@Board+780
	D = M
	M = 0
	@Board+908
	M = M + D

	@Board+909
	D = M
	M = 0
	@Board+781
	M = M + D

	@Board+910
	D = M
	M = 0
	@Board+1038
	M = M + D

	@Board+1039
	D = M
	M = 0
	@Board+911
	M = M + D

	@Board+1040
	D = M
	M = 0
	@Board+1168
	M = M + D

	@Board+1169
	D = M
	M = 0
	@Board+1041
	M = M + D

	@Board+1170
	D = M
	M = 0
	@Board+1298
	M = M + D

	@Board+1299
	D = M
	M = 0
	@Board+1171
	M = M + D

	@Board+1300
	D = M
	M = 0
	@Board+1428
	M = M + D

	@Board+1429
	D = M
	M = 0
	@Board+1301
	M = M + D

	@Board+1430
	D = M
	M = 0
	@Board+1558
	M = M + D

	@Board+1559
	D = M
	M = 0
	@Board+1431
	M = M + D

	@Board+1560
	D = M
	M = 0
	@Board+1688
	M = M + D

	@Board+1689
	D = M
	M = 0
	@Board+1561
	M = M + D

	@Board+1690
	D = M
	M = 0
	@Board+1818
	M = M + D

	@Board+1819
	D = M
	M = 0
	@Board+1691
	M = M + D

	@Board+1820
	D = M
	M = 0
	@Board+1948
	M = M + D

	@Board+1949
	D = M
	M = 0
	@Board+1821
	M = M + D

	@Board+1950
	D = M
	M = 0
	@Board+2078
	M = M + D

	@Board+2079
	D = M
	M = 0
	@Board+1951
	M = M + D

	@Board+2080
	D = M
	M = 0
	@Board+2208
	M = M + D

	@Board+2209
	D = M
	M = 0
	@Board+2081
	M = M + D

	@Board+2210
	D = M
	M = 0
	@Board+2338
	M = M + D

	@Board+2339
	D = M
	M = 0
	@Board+2211
	M = M + D

	@Board+2340
	D = M
	M = 0
	@Board+2468
	M = M + D

	@Board+2469
	D = M
	M = 0
	@Board+2341
	M = M + D

	@Board+2470
	D = M
	M = 0
	@Board+2598
	M = M + D

	@Board+2599
	D = M
	M = 0
	@Board+2471
	M = M + D

	@Board+2600
	D = M
	M = 0
	@Board+2728
	M = M + D

	@Board+2729
	D = M
	M = 0
	@Board+2601
	M = M + D

	@Board+2730
	D = M
	M = 0
	@Board+2858
	M = M + D

	@Board+2859
	D = M
	M = 0
	@Board+2731
	M = M + D

	@Board+2860
	D = M
	M = 0
	@Board+2988
	M = M + D

	@Board+2989
	D = M
	M = 0
	@Board+2861
	M = M + D

	@Board+2990
	D = M
	M = 0
	@Board+3118
	M = M + D

	@Board+3119
	D = M
	M = 0
	@Board+2991
	M = M + D

	@Board+3120
	D = M
	M = 0
	@Board+3248
	M = M + D

	@Board+3249
	D = M
	M = 0
	@Board+3121
	M = M + D

	@Board+3250
	D = M
	M = 0
	@Board+3378
	M = M + D

	@Board+3379
	D = M
	M = 0
	@Board+3251
	M = M + D

	@Board+3380
	D = M
	M = 0
	@Board+3508
	M = M + D

	@Board+3509
	D = M
	M = 0
	@Board+3381
	M = M + D

	@Board+3510
	D = M
	M = 0
	@Board+3638
	M = M + D

	@Board+3639
	D = M
	M = 0
	@Board+3511
	M = M + D

	@Board+3640
	D = M
	M = 0
	@Board+3768
	M = M + D

	@Board+3769
	D = M
	M = 0
	@Board+3641
	M = M + D

	@Board+3770
	D = M
	M = 0
	@Board+3898
	M = M + D

	@Board+3899
	D = M
	M = 0
	@Board+3771
	M = M + D

	@Board+3900
	D = M
	M = 0
	@Board+4028
	M = M + D

	@Board+4029
	D = M
	M = 0
	@Board+3901
	M = M + D

	@Board+4030
	D = M
	M = 0
	@Board+4158
	M = M + D

	@Board+4159
	D = M
	M = 0
	@Board+4031
	M = M + D

	@Board+4160
	D = M
	M = 0
	@Board+4288
	M = M + D

	@Board+4289
	D = M
	M = 0
	@Board+4161
	M = M + D

	@Board+4290
	D = M
	M = 0
	@Board+4418
	M = M + D

	@Board+4419
	D = M
	M = 0
	@Board+4291
	M = M + D

	@Board+4420
	D = M
	M = 0
	@Board+4548
	M = M + D

	@Board+4549
	D = M
	M = 0
	@Board+4421
	M = M + D

	@Board+4550
	D = M
	M = 0
	@Board+4678
	M = M + D

	@Board+4679
	D = M
	M = 0
	@Board+4551
	M = M + D

	@Board+4680
	D = M
	M = 0
	@Board+4808
	M = M + D

	@Board+4809
	D = M
	M = 0
	@Board+4681
	M = M + D

	@Board+4810
	D = M
	M = 0
	@Board+4938
	M = M + D

	@Board+4939
	D = M
	M = 0
	@Board+4811
	M = M + D

	@Board+4940
	D = M
	M = 0
	@Board+5068
	M = M + D

	@Board+5069
	D = M
	M = 0
	@Board+4941
	M = M + D

	@Board+5070
	D = M
	M = 0
	@Board+5198
	M = M + D

	@Board+5199
	D = M
	M = 0
	@Board+5071
	M = M + D

	@Board+5200
	D = M
	M = 0
	@Board+5328
	M = M + D

	@Board+5329
	D = M
	M = 0
	@Board+5201
	M = M + D

	@Board+5330
	D = M
	M = 0
	@Board+5458
	M = M + D

	@Board+5459
	D = M
	M = 0
	@Board+5331
	M = M + D

	@Board+5460
	D = M
	M = 0
	@Board+5588
	M = M + D

	@Board+5589
	D = M
	M = 0
	@Board+5461
	M = M + D

	@Board+5590
	D = M
	M = 0
	@Board+5718
	M = M + D

	@Board+5719
	D = M
	M = 0
	@Board+5591
	M = M + D

	@Board+5720
	D = M
	M = 0
	@Board+5848
	M = M + D

	@Board+5849
	D = M
	M = 0
	@Board+5721
	M = M + D

	@Board+5850
	D = M
	M = 0
	@Board+5978
	M = M + D

	@Board+5979
	D = M
	M = 0
	@Board+5851
	M = M + D

	@Board+5980
	D = M
	M = 0
	@Board+6108
	M = M + D

	@Board+6109
	D = M
	M = 0
	@Board+5981
	M = M + D

	@Board+6110
	D = M
	M = 0
	@Board+6238
	M = M + D

	@Board+6239
	D = M
	M = 0
	@Board+6111
	M = M + D

	@Board+6240
	D = M
	M = 0
	@Board+6368
	M = M + D

	@Board+6369
	D = M
	M = 0
	@Board+6241
	M = M + D

	@Board+6370
	D = M
	M = 0
	@Board+6498
	M = M + D

	@Board+6499
	D = M
	M = 0
	@Board+6371
	M = M + D

	@Board+6500
	D = M
	M = 0
	@Board+6628
	M = M + D

	@Board+6629
	D = M
	M = 0
	@Board+6501
	M = M + D

	@Board+6630
	D = M
	M = 0
	@Board+6758
	M = M + D

	@Board+6759
	D = M
	M = 0
	@Board+6631
	M = M + D

	@Board+6760
	D = M
	M = 0
	@Board+6888
	M = M + D

	@Board+6889
	D = M
	M = 0
	@Board+6761
	M = M + D

	@Board+6890
	D = M
	M = 0
	@Board+7018
	M = M + D

	@Board+7019
	D = M
	M = 0
	@Board+6891
	M = M + D

	@Board+7020
	D = M
	M = 0
	@Board+7148
	M = M + D

	@Board+7149
	D = M
	M = 0
	@Board+7021
	M = M + D

	@Board+7150
	D = M
	M = 0
	@Board+7278
	M = M + D

	@Board+7279
	D = M
	M = 0
	@Board+7151
	M = M + D

	@Board+7280
	D = M
	M = 0
	@Board+7408
	M = M + D

	@Board+7409
	D = M
	M = 0
	@Board+7281
	M = M + D

	@Board+7410
	D = M
	M = 0
	@Board+7538
	M = M + D

	@Board+7539
	D = M
	M = 0
	@Board+7411
	M = M + D

	@Board+7540
	D = M
	M = 0
	@Board+7668
	M = M + D

	@Board+7669
	D = M
	M = 0
	@Board+7541
	M = M + D

	@Board+7670
	D = M
	M = 0
	@Board+7798
	M = M + D

	@Board+7799
	D = M
	M = 0
	@Board+7671
	M = M + D

	@Board+7800
	D = M
	M = 0
	@Board+7928
	M = M + D

	@Board+7929
	D = M
	M = 0
	@Board+7801
	M = M + D

	@Board+7930
	D = M
	M = 0
	@Board+8058
	M = M + D

	@Board+8059
	D = M
	M = 0
	@Board+7931
	M = M + D

	@Board+8060
	D = M
	M = 0
	@Board+8188
	M = M + D

	@Board+8189
	D = M
	M = 0
	@Board+8061
	M = M + D

	@Board+8190
	D = M
	M = 0
	@Board+8318
	M = M + D

	@Board+8319
	D = M
	M = 0
	@Board+8191
	M = M + D

	@Board+8320
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+8449
	D = M
	M = 0
	@Board+8321
	M = M + D

	// Phase 3: use the previous generation state and the count of neighbors to update
	// the cells.

	@Board+Board_First_Cell // G.cell = first possible active cell
	D = A
	@G.cell
	M = D

(G.3.Top) 			// repeat ... until ++G.cell = Board+8449 (guard cell after last live cell)

	@G.cell 		// D = [G.cell]
	A = M
	D = M

	@G.3.Live 		// if D < 0 it's a live cell
	D ; JLT

(G.3.Dead)

	@G.3.Dead.Next 	// if D == 0 break. This is an efficiency hack; instead of paying a flat 6 instructions
	D ; JEQ 		// per cell, we can pay 2 if it has no neighbors and 8 if it does. This is a win if
					// the fast path happens more than 25% of the time, which it does.

	@DeadTable 		// D = DeadTable[D]
	A = A + D
	D = M

	@G.cell 		// [G.cell] = D
	A = M
	M = D

(G.3.Dead.Next)					// End of loop

	@G.cell 					// D = ++G.cell
	MD = M + 1

	@Board+Board_Last_Cell+1 	// if G.cell within range, loop
	D = D - A
	@G.3.Top
	D ; JLT

(G.3.Live)

	@0b1111 		// D = LiveTable[D & 1111] (we need to mask off the sign bit)
	D = D & A
	@LiveTable
	A = A + D
	D = M

	@G.cell 		// [G.cell] = D
	A = M
	M = D

(G.3.Live.Next)					// End-of-loop code is duplicated to save a jump

	@G.cell 					// D = ++G.cell
	MD = M + 1

	@Board+Board_Last_Cell+1 	// if G.cell within range, loop
	D = D - A
	@G.3.Top
	D ; JLT

// Jump directly to Paint_Board() without pushing return
// address on stack. It will return to my caller!

	@Paint_Board
	0 ; JMP

// Load_Board (LB) function. Expects address of board data loader code in D. Clears the board, unpacks the data,
// and sets up the cells.

(Load_Board)
(LB)

    @LB.board       // Save the new board's address
    M=D

// Clear the board by calling Clear_Board (CB) function

	@LB.Ret2 		// D = Clear board return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Clear_Board 	// Clear_Board()
	0 ; JMP

(LB.Ret2)

	@Board+Board_First_Cell
	D = A
	@LB.cell
	M = D

	@Board_Rows 	// LB.row = number of rows we need to read
	D = A
	@LB.row
	M = D

(LB.forRow) 		// repeat Load_Board_Row() while (--LB.row > 0)

	@LB.forRow.Ret 	// D = Load_Board_Row return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Load_Board_Row // Load_Board_Row()
	0 ; JMP

(LB.forRow.Ret)

	@LB.row 		// LB.row,D = LB.row - 1
	MD = M - 1
	
	@LB.forRow 		// Loop if LB.row > 0
	D ; JGT

// Paint the board by jumping directly to Paint_Board()
// It will return to my caller.

	@Paint_Board
	0 ; JMP

// Load_Board_Row function. Load a single row from 8 words starting at LB.board into
// 128 cells starting at LB.cell, then move LB.cell to the first cell of the next row
// and LB.board to the first word of the next row of board information.

(Load_Board_Row)
(LBR)

	@Board_Words_Per_Row // LBR.word = 8 (for 128 col board)
	D = A
	@LBR.word
	M = D

(LBR.forWord) 			// Repeat Load_Board_Word while (--LBR.word > 0)

	@LBR.forWord.Ret 	// D = Load_Board_Row return address
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Load_Board_Word	// Load_Board_Word()
	0 ; JMP

(LBR.forWord.Ret)

	@LBR.word 			// LBR.word,D = LBR.word - 1
	MD = M - 1
	
	@LBR.forWord		// Loop if LB.row > 0
	D ; JGT

	@LB.cell 			// LB.cell = LB.cell + 2
	M = M + 1
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Load_Board_Word(D): Use the 16 bits of [LB.board] to set the next
// D cells starting at [LB.cell]; increment LB.board and LB.cell.

(Load_Board_Word)
(LBW)

	@16 				// LBW.count = 16 (# of bits to transfer)
	D = A
	@LBW.count
	M = D

	@LB.board 			// @LBW.bits = [LB.board]
	A = M
	D = M
	@LBW.bits
	M = D

(LBW.forCell)			// Repeat [LB.cell++] = Top bit of LBW.bits while (--LBW.count > 0)

	@LBW.bits 			// D = LBW.bits
	D = M

	M = D + M 			// LBW.bits = LBW.bits << 1 (but D still has original LBW.bits)

	@32767				// D = D & 1000 0000 0000 0000
	D = ! D 			// We have to be tricky to do this because we can't
	D = D | A 			// load a 16 bit constant. The end result is that the
	D = ! D 			// sign bit is preserved and everything else is 0!

	@LB.cell 			// [LB.cell] = D
	A = M
	M = D

	D = A + 1 			// LB.cell++
	@LB.cell
	M = D

	@LBW.count 			// LBW.Count,D = LBW.Count.i - 1
	MD = M - 1
	
	@LBW.forCell		// Loop if CB.i > 0
	D ; JGT

(LBW.incBoard)

	@LB.board 			// LB.board++ 
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board (SB) function. Expects address of buffer to be saved into in D. Packs the data in
// the current board into this buffer. As such, it is the inverse of Load_Board().

(Save_Board)
(SB)

    @SB.board       // Save the new board's address
    M=D

	@Board+Board_First_Cell
	D = A
	@SB.cell
	M = D

	@Board_Rows 	// LB.row = number of rows we need to read
	D = A
	@SB.row
	M = D

(SB.forRow) 		// repeat Save_Board_Row() while (--SB.row > 0)

	@SB.forRow.Ret 	// D = Save_Board_Row return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Save_Board_Row // Save_Board_Row()
	0 ; JMP

(SB.forRow.Ret)

	@SB.row 		// SB.row,D = SB.row - 1
	MD = M - 1
	
	@SB.forRow 		// Loop if SB.row > 0
	D ; JGT

// All done, so return to caller

	@SP 			// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board_Row function. Stores a single row of 8 words starting at SB.board from
// 128 cells starting at SB.cell, then move SB.cell to the first cell of the next row
// and SB.board to the first word of the next row of board information.

(Save_Board_Row)
(SBR)

	@Board_Words_Per_Row // SBR.word = 8 (for 128 col board)
	D = A
	@SBR.word
	M = D

(SBR.forWord) 			// repeat Save_Board_Word while (--SBR.word > 0)

	@SBR.forWord.Ret 	// D = Save_Board_Row return address
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Save_Board_Word	// Save_Board_Word()
	0 ; JMP

(SBR.forWord.Ret)

	@SBR.word 			// LBR.word,D = LBR.word - 1
	MD = M - 1
	
	@SBR.forWord		// Loop if LB.row > 0
	D ; JGT

	@SB.cell 			// LB.cell = LB.cell + 2
	M = M + 1
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board_Word(D): Store the next 16 cells starting at [SB.cell] into
// [SB.board]; increment SB.board and SB.cell.

(Save_Board_Word)
(SBW)

	@16 				// SBW.count = 16 (# of bits to transfer)
	D = A
	@SBW.count
	M = D

	@SBW.bits			// SBW.bits = 0 (we will accumulate them here)
	M = 0

(SBW.forCell)			// repeat shifting bits into SBW.bits based on the cell values.

	@SBW.bits 			// SBW.bits << 1
	D = M
	M = M + D

	@SB.cell			// D = [SB.cell]
	A = M
	D = M

	@SBW.nextCell		// Skip to next if dead cell (0)
	D ; JEQ

	@SBW.bits			// SBW.bits++
	M = M + 1

(SBW.nextCell)

	@SB.cell			// SB.cell++
	M = M + 1

	@SBW.count 			// SBW.Count,D = SBW.Count.i - 1
	MD = M - 1
	
	@SBW.forCell		// Loop if SBW.count > 0
	D ; JGT

(SBW.storeBoard)

	@SBW.bits			// [SB.board] = SBW.bits
	D = M
	@SB.board
	A = M
	M = D

	@SB.board			// SB.board++
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Clear_Board (CB) function. Clears all the cells including the border guard cells
// Should rewrite to not need the count variable. Lazy.

(Clear_Board)
(CB)

	@Board_Size		// 128x64 board has 130x66 cells
	D = A 			// CB.i is the loop counter
	@CB.i
	M = D

	@Board 			// CB.a = Board location
	D = A
	@CB.a
	M = D
	
(CB.Top)			// Repeat Mem[CB.a++] = 0 while (--CB.i > 0) 

	@CB.a 			// [CB.a] = 0
	A = M
	M = 0
	
	D = A + 1 		// D = CB.a + 1
	@CB.a 			// CB.a = D
	M = D

	@CB.i 			// CB.i,D = CB.i - 1
	MD = M - 1
	
	@CB.Top 		// Loop if CB.i > 0
	D ; JGT

// Return to caller.

	@SP 			// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Paint_Board (PB) function; paints the current board onto the screen.

(Paint_Board)
(PB)

	@SCREEN 				// PB.board = Address of screen
	D = A
	@PB.board
	M = D

	@Board+Board_First_Cell // PB.cell = First real cell of the board
	D = A
	@PB.cell
	M = D

	@Board_Rows 			// PB.row = 64 (number of rows we need to paint)
	D = A
	@PB.row
	M = D

(PB.forRow) 				// Repeat Paint_Board_Row() while (--PB.row > 0)

	@PB.forRow.Ret 			// D = Paint_Board_Row return address
	D = A

	@SP 					// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Paint_Board_Row 		// Paint_Board_Row()
	0 ; JMP

(PB.forRow.Ret)

	@PB.row 				// PB.row,D = PB.row - 1
	MD = M - 1
	
	@PB.forRow 				// Loop if PB.row > 0
	D ; JGT

// Return to caller.

	@SP 					// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Paint_Board_Row(): Paint a single row (128 cells) onto the screen. We use an 4x4 matrix of pixels
// for each cell, so four cells fit into each word of pixels (16 pixels/word), and each row is
// replicated 4 times. On exit, PB.board points to the first word of pixels for the next row of
// cells, and PB.cell points to the first cell of the next row.

(Paint_Board_Row)
(PBR)

	@Board_Cols/4 		// PBR.quad = 32 (number of quads of cells we need to paint)
	D = A
	@PBR.quad
	M = D

(PBR.forQuad) 			// repeat Paint_Board_Quad() while (--PBR.quad > 0)

// Paint_Board_Quad(): paint a quad of cells [PB.cell] ... [PB.cell+3] onto the screen at word
// [PB.board]. Repeat for 4 screen rows, then update PB.cell and PB.board for the next
// iteration.
//
// This code is executed so much that all sorts of optimizations are warranted, including
// inserting it here as an inlined function call to avoid the call-return overhead. This
// sucks a bit for readability.

(Paint_Board_Quad)
(PBQ)

	// Convert cells into pixels. There are 16 possible cell values, so we use an IF-ladder
	// to figure out what case we are in, and set D to the correct pixel value.

	@PB.cell 			// D = [PB.cell] (will be negative if cell is alive; 0 if cell is dead)
	A = M
	D = M

	@PBQ.0XXX			// Skip if first pixel is 0
	D ; JEQ

(PBQ.1XXX) 				// First pixel is set. What about second pixel?

	@PB.cell 			// D = [++PB.cell] (the second cell in the pair)
	AM = M + 1
	D = M

	@PBQ.10XX 			// Skip if second pixel is 0
	D ; JEQ

(PBQ.11XX) 				// Repeat process for third pixel

	@PB.cell 			// D = [++PB.cell]
	AM = M + 1
	D = M

	@PBQ.110X
	D ; JEQ

(PBQ.111X) 				// And finally for last pixel

	@PB.cell 			// D = [++PB.cell]
	AM = M + 1
	D = M

	@PBQ.1110
	D ; JEQ

// In the special case of all four cells set, we can optimize and
// just paint 0b1111111111111111 (-1) into the four scan lines.

(PBQ.1111)					// All pixels are set

	@Screen_Words_Per_Row	// D = 32 (offset to next scan line)
	D = A
	@PB.board				// A = [PB.board]
	A = M
	M = -1					// All pixels are set, so we have this optimization
	A = A + D				// Move to next scan line
	M = -1					// Paint it as well.
	A = A + D				// Move to next scan line
	M = -1					// Paint it as well.
	A = A + D				// Move to next scan line
	M = -1					// Paint it as well.

	@PB.board 				// PB.board = PB.board + 1
	M = M + 1

	@PB.cell 				// PB.cell = PB.cell + 1
	M = M + 1

// Return to caller.

	@PBR.forQuad.Ret 		// direct jump since this is an inline function call
	0 ; JMP

(PBQ.1110)					// If the pattern is not all 1's or 0's, we load the appropriate
							// bit pattern and jump to the generic routine. Note that we
	@0x0FFF					// need to reverse the bit pattern because of pixel ordering
	D = A 					// on screen.

	@PBQ.Paint				// Jump to the painter.
	0 ; JMP

// The rest of the ladder is cut and paste from above with different pixel values.

(PBQ.110X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.1100
	D ; JEQ

(PBQ.1101)

	@0xFFFF-0xF0FF			// Because we can't directly set the high bit, we have
	D = 0xFFFF 				// to do a little bit-fu in half our our cases.
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.1100)

	@0x00FF
	D = A

	@PBQ.Paint
	0 ; JMP

(PBQ.10XX)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.100X
	D ; JEQ

(PBQ.101X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.1010
	D ; JEQ

(PBQ.1011)

	@0xFFFF-0xFF0F
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.1010)

	@0x0F0F
	D = A

	@PBQ.Paint
	0 ; JMP

(PBQ.100X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.1000
	D ; JEQ

(PBQ.1001)

	@0xFFFF-0xF00F
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.1000)

	@0x000F
	D = A

	@PBQ.Paint
	0 ; JMP

(PBQ.0XXX)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.00XX
	D ; JEQ

(PBQ.01XX)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.010X
	D ; JEQ

(PBQ.011X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.0110
	D ; JEQ

(PBQ.0111)

	@0xFFFF-0xFFF0
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.0110)

	@0x0FF0
	D = A

	@PBQ.Paint
	0 ; JMP

(PBQ.010X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.0100
	D ; JEQ

(PBQ.0101)

	@0xFFFF-0xF0F0
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.0100)

	@0x00F0
	D = A

	@PBQ.Paint
	0 ; JMP

(PBQ.00XX)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.000X
	D ; JEQ

(PBQ.001X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.0010
	D ; JEQ

(PBQ.0011)

	@0xFFFF-0xFF00
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP

(PBQ.0010)

	@0x0F00
	D = A

	@PBQ.Paint
	0 ; JMP
	
(PBQ.000X)

	@PB.cell
	AM = M + 1
	D = M

	@PBQ.0000
	D ; JEQ

(PBQ.0001)

	@0xFFFF-0xF000
	D = 0xFFFF
	D = D - A 

	@PBQ.Paint
	0 ; JMP
	
(PBQ.0000)				// All 0's is another special case

	@Screen_Words_Per_Row
	D = A
	@PB.board
	A = M
	M = 0
	A = A + D
	M = 0
	A = A + D
	M = 0
	A = A + D
	M = 0

	@PB.board 			// PB.board = PB.board + 1
	M = M + 1

	@PB.cell 			// PB.cell = PB.cell + 1
	M = M + 1

// Return to caller.

	@PBR.forQuad.Ret 	// direct jump since this is an inline function call
	0 ; JMP

// Paint the pixels in D into 4 successive rows of the screen.
// Loop is unrolled for efficiency.

(PBQ.Paint)

	@PBQ.pixels 		// Save our pixels
	M = D

	@PB.board 			// A = PB.board (location of first screen word to bash)
	A = M

	M = D 				// [PB.board] = PBQ.pixels (still in D) -- row 0

	D = A 				// PB.board = PB.board + 32
	@Screen_Words_Per_Row
	D = D + A
	@PB.board
	M = D

	@PBQ.pixels 		// [PB.board] = PBQ.pixels -- row 1
	D = M
	@PB.board
	A = M
	M = D


	D = A 				// PB.board = PB.board + 32
	@Screen_Words_Per_Row
	D = D + A
	@PB.board
	M = D

	@PBQ.pixels 		// [PB.board] = PBQ.pixels -- row 2
	D = M
	@PB.board
	A = M
	M = D

	D = A 				// PB.board = PB.board + 32
	@Screen_Words_Per_Row
	D = D + A
	@PB.board
	M = D

	@PBQ.pixels 		// [PB.board] = PBQ.pixels -- row 3
	D = M
	@PB.board
	A = M
	M = D

// PB.board now contains an address in the 4th row. We need to go back to
// the first row, then move forward to the next word. Since we moved 3 x 32
// words, we simply subtract (3*32)-1. Similarly, we need to increment
// PB.cell to move to the first cell of the next pair.

(PBQ.NextQuad)

	@95 				// PB.board = PB.board - 95
	D = A
	@PB.board
	M = M - D

	@PB.cell
	M = M + 1

// Inliine function, so we just fall through.

(PBR.forQuad.Ret)

	@PBR.quad 			// PB.pair,D = PB.pair - 1
	MD = M - 1
	
	@PBR.forQuad		// Loop if PBR.quad > 0
	D ; JGT

// Update PB.cell and PB.board so they are correct for the next iteration.

	@PB.cell 			// PB.cell = PB.cell + 2 (skips border cells)
	M = M + 1
	M = M + 1

	@96 				// PB.board = PB.board + 32 * 3 (skips 3 pixel rows)
	D = A
	@PB.board
	M = M + D

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP
