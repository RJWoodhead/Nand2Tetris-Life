//
// VERSION 2 - Uses bit 4 to store life cell status.
//
// Conway's Game of Life in Hack Assembly language -- https://en.wikipedia.org/wiki/Conway's_Game_of_Life
//
// (C)2023 Robert Woodhead - trebor@animeigo.com / @madoverlord - Creative Commons Attribution License
//
// I am indebted to http://www.conwaylife.com/wiki/Main_Page, the LifeWiki, which is a great resource
// for finding interesting Life Patterns.
//
// Notes on implementation:
//
// Game Board: a 128x64 matrix of cells, wrapping around at the edges, so the board is effectively a torus.
// This maps onto the display screen with each cell taking up 4x4 pixels. The game board is stored as a
// 130x66 matrix with guard cells around the edges that are used to both simplify the code and implement
// the wrapping feature.
//
// Typical simple implementations of Life store multiple cells per word and use clever bit-banging techniques
// to update them in parallel to minimize the number of operations (especially memory fetches on machines
// where those are expensive). However, the Hack machine architecture is not well suited to these techniques
// so each cell is implemented as a full word as follows: 0000 0000 000L NNNN, where L is whether the cell is
// alive or dead, and NNNN is a count of the number of live neighbors. In the first pass, each cell has 1 added
// to it for each live neighbor. Then in a second pass, a table lookup is used to convert the neighbor count
// into the new value for the cell. Finally, the screen is updated to reflect the new board state.
//
// The original version of the program used the high (sign) bit to store the cell state because it was easier to
// check the status of the cell. However, restructuring the cell data in this way permits a tradeoff that makes
// the first pass slightly slower but speeds up the second pass and the screen update.
//
// Keyboard commands:
//
// 0-9		Load prestored board (0 = logo board)
// Space 	Compute Next Generation
// Return 	Free-run until another key pressed
// Arrows 	Move editing cursor up/down/right/left
// Q W E 	8-way cursor movement
// A   D
// Z X C
// ` or S 	Toggle current cell
// DEL 		Clear board
// < or ,	Push board into undo stack
// > or . 	Restore board from undo stack
//
// Note: HACK CPU emulator returns uppercase keyboard keys regardless of state of SHIFT or CAPSLOCK keys!

// Nomenclature Note:
//
// I put an identifying label at the start of each code segment or subroutine.
// Variables and labels defined inside that section of code all have names that
// are prefixed by the name of the code segment.
//
// So segment (SEG) will have labels like (SEG.Label) and variables like @SEG.x and @SEG.y.z.
//
// If the segment name is long, I will sometimes have a second shorter version of
// the naming label, so the sublabels and variable names can be shorter. IE:
//
// (Very.Long.Label.Name)
// (VLLN)
//
// 		@VLLN.xpos
//
// This makes it easier to find variables and labels in the symbol table generated by
// the assembler.

// Global constants and variables.

#BOARD_ROWS=64											// Size of the life board.
#BOARD_COLS=128
#BOARD_SIZE=(BOARD_ROWS+2)*(BOARD_COLS+2)   			// Space required (including guard cells).
#BOARD_FIRST_CELL=BOARD_COLS+3							// Offset of first actual cell (0,0).
#BOARD_LAST_CELL=BOARD_SIZE-(BOARD_COLS+4)				// Offset of last actual cell (BOARD_COLS,BOARD_ROWS).

#COMPRESSED_BOARD_SIZE=(BOARD_ROWS*BOARD_COLS)/16		// Size of a compressed board.
#BOARD_WORDS_PER_ROW=BOARD_COLS/16						// # of words per row of compressed board.
#SCREEN_WORDS_PER_ROW=32								// # of words per scan line on the screen.

// Cell values. Note that some code depends on DEAD being 0x0000, so in the unlikely event that
// this ever changes, check for DEAD in comments to find the dependencies.

#ALIVE=0x0010											// Cell status is alive.
#DEAD =0x0000											// Cell status is dead.
#END_M=-1												// Special end-of-board mark.

// Board data storage.

$Board(BOARD_SIZE)

// Special value that lets us know we've reached the end of the board data. -1 is a value that can
// never be in the board data, and it's easy to test. If we ever loop through the board and get to
// this cell, we know we're done. It is slightly faster to check this than check to see if the
// loop counter has reached the end mark. More details in the actual code.

$BoardEndMark=END_M

// Since only R0 is used (for SP), R1-R15 can be reallocated to save a little ram space. In this
// program, R1-R15 are used as scratchpad temp variables that are not preserved over function
// calls. Alias declarations are used to define these variables.

// We can have as many undo buffers as space permits. Boards are stored in the undo buffers as bitmaps,
// so we have to compress them when saving and can use the stored board load routine to restore them.

#UNDO_DEPTH=4											// How many Undo buffers do we have?
#UNDO_SIZE=UNDO_DEPTH*COMPRESSED_BOARD_SIZE				// Total size of the buffers.

$Undo(UNDO_SIZE)										// The buffers themselves.

#UNDO_COPY_LEN=(UNDO_DEPTH-1)*COMPRESSED_BOARD_SIZE		// How much do we copy on a push or pop?
#UNDO_PUSH_FROM=Undo+UNDO_COPY_LEN-1					// From/To copy locations for pushing a buffer.
#UNDO_PUSH_TO=UNDO_PUSH_FROM+COMPRESSED_BOARD_SIZE		// This copy proceeds backwards to start.
#UNDO_POP_FROM=Undo+COMPRESSED_BOARD_SIZE				// Same for popping a buffer, but this copy
#UNDO_POP_TO=Undo										// proceeds forwards.

// Start of program; Initialize stack.

(START)

	@SCREEN 		// Initialize SP to SCREEN - 1.
	D = A - 1
	@SP
	M = D

// Load the splash screen.

(Logo.Load)

	@Logo.Load.Ret	// D = return address (calling convention).
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Logo.png 		// D = Address of the compressed board image (defined at end of file).
	D = A

	@Load_Board 	// Load_Board()
	0 ; JMP

(Logo.Load.Ret)		// Return from Load_Board here.

// Main program UI loop. Each section of the program begins with definitions of the variables
// that are first used in the section. Variable names are in the format <section>.<name>, the
// same as we use with labels; it's basically a manual way of scoping them.

(Life)

$Life.X=64				// X cursor position.
$Life.Y=32				// Y cursor position.

#Life.SPEED=32767		// How fast does cursor blink?
$Life.Blink=Life.SPEED	// Blink loop counter.

$Life.Key				// Current key temp variable

	@KBD 			// Life.Key = [KBD]
	D = M
	@Life.Key
	M = D

	@Key.Up 		// Skip to end of key processing loop if we have a key.
	D ; JNE 		// This handles issue of stale key on program start.

// Loop processing keys, blinking cursor while waiting.

(Key.Down) 			// Loop until key pressed.

	@KBD 			// D = [KBD]
	D = M

	@Key.Pressed 	// if a key has been pressed, process it.
	D ; JNE

	D = D 			// NOP instructions to slow down this loop.
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D
	D = D

	@Life.Blink 	// if --Life.Blink == 0, blink cursor.
	MD = M - 1
	@Key.Down
	D ; JNE

// Blink the cursor by XORing the inner block of 2x2 pixels in a life cell on screen.

(Blink)

$Blink.Mask			// Mask selected from Blink.Bits.
$Blink.Old 			// The old value of the screen word.
$Blink.New			// The new value of the screen word (Blink.Old XOR Blink.Mask).
$Blink.Or			// Temp variable used during XOR.
$Blink.Word			// Address in screen memory to update.

// Divide-by-4 table.

$Blink.Div4(128)=0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,\
	11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,\
	19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,26,26,26,26,\
	27,27,27,27,28,28,28,28,29,29,29,29,30,30,30,30,31,31,31,31

// Table of bitmap masks used to blink the cursor (4 cells per word in SCREEN memory).

$Blink.Bits(4)=0b0000000000000110,0b0000000001100000,0b0000011000000000,0b0110000000000000

	@Life.SPEED 	// Life.Blink = Life.SPEED (resets blink count).
	D = A
	@Life.Blink
	M = D

// Compute the location in the screen buffer of the current cursor position.
// There are 32 words per row, and 4 rows per cell. 32*4 = 128. We also skip
// a row because we only modify the central 2x2 pixels of a cell. We could
// use a table for *128 but speed isn't needed here.

	@Life.Y 		// Blink.Word = (Life.Y * 128) + SCREEN + 32
	AD = M          // we can get a little clever here by storing the results
	AD = D + A      // in both A and D, and then adding them together.
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	AD = D + A
	@SCREEN+32      // Skip the first row (since we xor inner 2x2 of 4x4 cell)
	D = D + A
	@Blink.Word		// Blink.Word points to the first word in the correct row
	M = D			// of screen memory.

// Each word in the screen buffer holds the bits for four adjacent cells.
// Do a table lookup to get the desired bitmap.

	@0x0003			// D = the low two bits of Life.X.
	D = A			
	@Life.X
	D = D & M
	@Blink.Bits		// D = Blink.Bits[D]
	A = D + A
	D = M

	@Blink.Mask 	// Blink.Mask = XOR mask of bits to flip.
	M = D

	@Life.X 		// Blink.Word = Blink.Word + Life.X / 4
	D = M 			// Since we don't have a shift-right instruction
	@Blink.Div4 	// we use a lookup table.
	A = D + A
	D = M

	@Blink.Word 	// Also save Blink.Word in A, so M then points to the
	AM = D + M 		// first word in screen memory we want to alter.

	D = M 			// Blink.Old = [Blink.Word] (the old screen bitmap)
	@Blink.Old		// We could refactor to eliminate this variable but
	M = D			// I have left it present for clarity.

	@Blink.Mask 	// Blink.New = Blink.Old XOR Blink.Mask
	D = D | M 		// XOR(A,B) = (A|B) & !(A&B)
	@Blink.Or
	M = D

	@Blink.Old
	D = M
	@Blink.Mask
	D = D & M
	D = !D

	@Blink.Or
	D = D & M

	@Blink.New		// [Blink.Word] = Blink.New (top 2x1 pixels).
	M = D

	@Blink.Word
	A = M
	M = D

	@SCREEN_WORDS_PER_ROW	// Move down one row.
	D = A
	@Blink.Word
	M = M + D

	@Blink.New		// [Blink.Word] = Blink.New (bottom 2x1 pixels).
	D = M

	@Blink.Word
	A = M
	M = D

	@Key.Down 		// Resume looking for a key.
	0 ; JMP

// Decode keypresses.

(Key.Pressed)

	@Life.Key 		// Life.Key = D
	M = D

	// Arrow keys

	@Life.Key 		// Up.
	D = M
	@KBD_UPARROW
	D = D - A
	@Key.MoveUp
	D ; JEQ

	@Life.Key 		// Down.
	D = M
	@KBD_DOWNARROW
	D = D - A
	@Key.MoveDown
	D ; JEQ

	@Life.Key 		// Right.
	D = M
	@KBD_RIGHTARROW
	D = D - A
	@Key.MoveRight
	D ; JEQ

	@Life.Key 		// Left.
	D = M
	@KBD_LEFTARROW
	D = D - A
	@Key.MoveLeft
	D ; JEQ

	// 8-way keys

	@Life.Key 		// W = Up.
	D = M
	@"W"
	D = D - A
	@Key.MoveUp
	D ; JEQ

	@Life.Key 		// X = Down.
	D = M
	@"X"
	D = D - A
	@Key.MoveDown
	D ; JEQ

	@Life.Key 		// D = Right.
	D = M
	@"D"
	D = D - A
	@Key.MoveRight
	D ; JEQ

	@Life.Key 		// A = Left.
	D = M
	@"A"
	D = D - A
	@Key.MoveLeft
	D ; JEQ

	@Life.Key 		// Q = Up-Left.
	D = M
	@"Q"
	D = D - A
	@Key.MoveUpLeft
	D ; JEQ

	@Life.Key 		// E = Up-Right.
	D = M
	@"E"
	D = D - A
	@Key.MoveUpRight
	D ; JEQ

	@Life.Key 		// Z = Down-Left.
	D = M
	@"Z"
	D = D - A
	@Key.MoveDownLeft
	D ; JEQ

	@Life.Key 		// C = Down-Right.
	D = M
	@"C"
	D = D - A
	@Key.MoveDownRight
	D ; JEQ

	@Life.Key 		// Space bar (single generation).
	D = M
	@KBD_SPACE 			
	D = D - A
	@Key.Space 			
	D ; JEQ

	@Life.Key 		// Enter (free run).
	D = M
	@KBD_NEWLINE
	D = D - A
	@Key.Enter
	D ; JEQ

	@Life.Key 		// DEL.
	D = M
	@KBD_BACKSPACE
	D = D - A
	@Key.Clear
	D ; JEQ

	@Life.Key 		// ` = Toggle cell.
	D = M
	@96
	D = D - A
	@Key.Toggle
	D ; JEQ

	@Life.Key 		// S = Toggle cell.
	D = M
	@"S"
	D = D - A
	@Key.Toggle
	D ; JEQ

	@Life.Key		// < = Push into undo buffer.
	D = M
	@"<"
	D = D - A
	@Key.Push
	D ; JEQ
	
	@Life.Key		// Alternate key.
	D = M
	@","
	D = D - A
	@Key.Push
	D ; JEQ
	
	@Life.Key		// < = Pop from undo buffer.
	D = M
	@">"
	D = D - A
	@Key.Pop
	D ; JEQ
	
	@Life.Key		// Alternate key.
	D = M
	@"."
	D = D - A
	@Key.Pop
	D ; JEQ

// Last thing we check is loading prestored patterns. First, we
// prepare for an eventual function call to Load_Board(), with
// a direct return to the end of our keyboard handler.

	@Key.Up
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	// Next, we look for a pattern key and set the D register with the
	// address of the board. The simple way is to subtract "0" from
    // the key, and then keep decrementing it until we get a 0 result
    // (or fall off the end).

	@Life.Key
	D = M
	@"0"
	D = D - A

	@Key.Pattern0
	D ; JEQ

	D = D - 1
	@Key.Pattern1
	D ; JEQ

	D = D - 1
	@Key.Pattern2
	D ; JEQ

	D = D - 1
	@Key.Pattern3
	D ; JEQ

	D = D - 1
	@Key.Pattern4
	D ; JEQ

	D = D - 1
	@Key.Pattern5
	D ; JEQ

	D = D - 1
	@Key.Pattern6
	D ; JEQ

	D = D - 1
	@Key.Pattern7
	D ; JEQ

	D = D - 1
	@Key.Pattern8
	D ; JEQ

	D = D - 1
	@Key.Pattern9
	D ; JEQ

// Unimplemented board pattern labels go here so they
// effectively become no-ops.

(Key.Pattern7)
(Key.Pattern8)
(Key.Pattern9)

// If we get to here, we don't have a valid board, so we need
// to restore the SP.

	@SP 			// Pop the un-needed return address off stack
	M = M + 1

	@Key.Up 		// And skip to the bottom of the handler
	0 ; JMP

// Individual handlers for each stored pattern. They just set D
// to the address of the pattern and jump to Load_Board.

(Key.Pattern0)
	
	@Logo.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern1)

	@Samples.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern2)

	@Shimon.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern3)

	@NAND_11.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern4)

	@NAND_01.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern5)

	@NAND_10.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

(Key.Pattern6)

	@NAND_00.png
	D = A
	@Load_Board 	// Load_Board() will return to Key.Up
	0 ; JMP

// Space bar - run a generation.

(Key.Space)

	@Key.Space.Ret	// D = Generation return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Generation 	// Generation()
	0 ; JMP

(Key.Space.Ret)

	@Key.Up
	0 ; JMP

// C - clear the board.

(Key.Clear)

	@Key.Change		// D = return directly to Key.Change handler below
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Clear_Board 	// Clear_Board()
	0 ; JMP

// < - Push the current board. First, we shift down the current boards
// in the Undo buffer (proceeding from bottom upwards so as not to smash
// stuff before it gets copied), and then we compress the board and
// store it at the top of the buffer.

// Parameters for Load_Board() and Save_Board()

$Undo.Count				// Count of # of words to move.
$Undo.From				// From Address.
$Undo.To				// To Address.

(Key.Push)

	@UNDO_COPY_LEN		// Undo.Count = # of words to copy.
	D = A
	@Undo.Count
	M = D

	@UNDO_PUSH_FROM		// Undo.From = Undo.
	D = A
	@Undo.From
	M = D

	@UNDO_PUSH_TO		// Undo.To = Undo2.
	D = A
	@Undo.To
	M = D

(Key.Push.Loop)

	@Undo.From			// [Undo.To] = [Undo.From]
	A = M
	D = M
	@Undo.To
	A = M
	M = D

	@Undo.From			// Undo.From--
	M = M - 1

	@Undo.To			// Undo.To--
	M = M - 1

	@Undo.Count			// Undo.Count--, also copy result to D
	MD = M - 1

	@Key.Push.Loop		// Loop if we have more to do
	D ; JNE

	@Key.Change 		// Call Save_Board(), return direct to end of keyboard handler
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Undo					// D = Undo Buffer location
	D = A
	@Save_Board				// Save_Board()
	0 ; JMP

// > - Restore the board. This time we load the top board in the
// Undo buffer, then move everything else up. Note that in this
// case the direction of copy is opposite to the push case.

(Key.Pop)

	@Key.Pop.Ret		// D = return address
	D = A

	@SP 				// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Undo 				// D = Address of the compressed board image.
	D = A

	@Load_Board 		// Load_Board()
	0 ; JMP

(Key.Pop.Ret)

	@UNDO_COPY_LEN		// Undo.Count = # of words to copy.
	D = A
	@Undo.Count
	M = D

	@UNDO_POP_FROM		// Undo.From = Source
	D = A
	@Undo.From
	M = D

	@UNDO_POP_TO		// Undo.To = Destination
	D = A
	@Undo.To
	M = D

(Key.Pop.Loop)

	@Undo.From			// [Undo.To] = [Undo.From]
	A = M
	D = M
	@Undo.To
	A = M
	M = D

	@Undo.From			// Undo.From++
	M = M + 1

	@Undo.To			// Undo.To++
	M = M + 1

	@Undo.Count			// Undo.Count--, also copy result to D.
	MD = M - 1

	@Key.Pop.Loop		// Loop if we have more to do.
	D ; JNE

	@Key.Change 		// Done.
	0 ; JMP

// In all the cursor routines, we use a bitmask to keep the x,y position in bounds.
// This only works if the bounds are a power of 2. If we are moving diagonally,
// we can move in one direction and then fall through to the code that moves
// in the other direction.

// UpLeft - move cursor.

(Key.MoveUpLeft)

	@BOARD_COLS-1	// Move left, then fall through to move up.
	D = A
	@Life.X
	M = M - 1
	M = D & M

// Up - move cursor.

(Key.MoveUp)

	@BOARD_ROWS-1
	D = A
	@Life.Y
	M = M - 1
	M = D & M

	@Key.Change
	0 ; JMP

// DownRight - move cursor.

(Key.MoveDownRight)

	@BOARD_COLS-1
	D = A
	@Life.X
	M = M + 1
	M = D & M

// Down - move cursor.

(Key.MoveDown)

	@BOARD_ROWS-1
	D = A
	@Life.Y
	M = M + 1
	M = D & M

	@Key.Change
	0 ; JMP

// DownLeft - move cursor.

(Key.MoveDownLeft)

	@BOARD_ROWS-1
	D = A
	@Life.Y
	M = M + 1
	M = D & M

// Left - move cursor.

(Key.MoveLeft)

	@BOARD_COLS-1
	D = A
	@Life.X
	M = M - 1
	M = D & M

	@Key.Change
	0 ; JMP

// UpRight - move cursor.

(Key.MoveUpRight)

	@BOARD_ROWS-1
	D = A
	@Life.Y
	M = M - 1
	M = D & M

// Right - move cursor.

(Key.MoveRight)

	@BOARD_COLS-1
	D = A
	@Life.X
	M = M + 1
	M = D & M

	@Key.Change
	0 ; JMP

// Toggle current cell.

(Key.Toggle)
(Toggle)

$Toggle.Cell		// Local variable

	@Life.Y         // Cell Address = (BOARD_COLS+2)*(Life.Y+1) + Life.X + Address of Board + 1
	AD = M + 1		// AD = Life.Y + 1
	AD = A + D 		// *2
	AD = A + D 		// *4
	AD = A + D 		// *8
	AD = A + D 		// *16
	AD = A + D 		// *32
	AD = A + D 		// *64
	AD = A + D 		// *128 (Depends on BOARD_COLS being 128).
	@Life.Y 		// Need to get to *130, so add Life.Y+1 in again twice.
	D = D + M
	D = D + M
	D = D + 1
	D = D + 1

 	@Life.X         // D = D + Life.X
	D = D + M

	@Board+1		// D = D + Address of Board + 1
	D = D + A

	@Toggle.Cell    // Save it for later and also move to
    AM = D          // A register so we can look at it.

    D = M           // Get value of cell. Assumes DEAD is 0x0000.
	@Key.Make.Live  // If dead, make alive, and vice-versa.
    D ; JEQ

(Key.Make.Dead)

    D = 0           // Assumes DEAD is 0x0000.
	@Toggle.Cell    // Address of current cell.
    A = M
    M = D           // Update value.
	@Key.Change     // And return.
	0 ; JMP

(Key.Make.Live)

	@ALIVE			// D = ALIVE
    D = A
	@Toggle.Cell    // Address of current cell.
    A = M
    M = D           // Update value.
	@Key.Change     // And return.
	0 ; JMP

// Enter - run generations until another key pressed.

(Key.Enter)

	@Key.Enter.Ret	// D = Generation return address
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Generation 	// Generation()
	0 ; JMP

(Key.Enter.Ret)

	@KBD 			// Do another generation if KBD == Life.Key (either 128 or 0).
	D = M
	@Life.Key
	D = D - M
	@Key.Enter
	D ; JEQ

	@Life.Key 		// Reset the current key (so we will catch "no key" just above, but now Enter will stop us).
	M = 0

	@KBD 			// If no key, we can loop.
	D = M
	@Key.Enter
	D ; JEQ

	@Life.Key 		// Restore Life.Key to current key, so it'll be debounced below.
	M = D

	@Key.Up 		// Terminate looping.
	0 ; JMP

// Handle changes in state by repainting the screen (and jump to Key.Up handler on return).

(Key.Change)

	@Key.Up			// D = return address.
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Paint_Board 	// Paint_Board()
	0 ; JMP

// Bottom of key processing loop.

(Key.Up)			// Loop until KBD no longer Life.Key (either new key or key up).

	@Life.Key
	D = M
	@KBD
	D = D - M
	@Key.Up
	D ; JEQ

	@Key.Down 		// Return to checking for new key.
	0 ; JMP

// End of program infinite loop, not actually reachable but all programs are
// supposed to have one, so...

	@DONE
(DONE)
	0 ; JMP

// Generation: runs a single generation of Life, then updates the board display.

(Generation)
(G)

$G.Cell							// Address of current cell

	@Board+BOARD_FIRST_CELL-1	// G.Cell = Address prior to the first real cell.
	D = A
	@G.Cell
	M = D

// Phase 1: for each living cell (not counting the guard cells), increment all
// the neighbors, so they have a count of how many neighbors they have. Note that
// we can plow through all the guard cells on left and right because they will
// always be dead, and it's faster to do this than do a double-loop with skip.
// Furthermore, we use a jump table to implement a case statement that handles
// all the possible cell values (dead (0-15), live (16-31), or end-mark (-1)).
// Finally, we can merge the load cell value code with the move to next cell
// code to save instructions.

$G.1.Case(33) = G.2, \		// Jump table for decoding value of cell.
	G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, \
	G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, G.1.Next, \
	G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, \
	G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live, G.1.Live

(G.1.Next) 					// repeat check_cell until we hit the special end-of-board cell.

	@G.Cell					// D = [++G.Cell]
	AM = M + 1
	D = M

// Much of the time, the cell value will be 0; any dead cell not adjacent to a live
// cell will never get incremented. We can do a check for this common case and jump
// directly to checking the next cell at a cost of 2 instructions. Since the most
// general path is 4 instructions, this is a win if non-neighbor dead cells are
// more than 50% of the board (we will save 2 instructions when we hit and pay
// 2 instructions when we miss, so we need more hits than misses to make it
// a good trade). On a typical life-board, 80%+ of the board will be non-neighbor
// dead cells, so it's a worthwhile optimization.

	@G.1.Next				// Shortcut for the most common case (Cell = 0)
	D ; JEQ

	@G.1.Case+1				// Index value into jump table (-1 value = end of board).
	A = A + D
	A = M 					// Load jump target from the table.
	0 ; JMP					// And we either loop, update neighbors, or quit.

(G.1.Live)					// If a live cell, we must increment neighbors.

// In the increment neighbor path, there is another subtle optimization that we
// can do to shave a few instructions. Since we can directly increment the cells
// themselves, the D-register is not needed after we compute the first neighbor
// address. We can thus take advantage of the HACK machine's ability to store
// results in multiple registers to save a copy of the address in D as well as
// A when we update it, which reduces the cost of moving to the next row by
// one instruction, for a total of two instructions per live cell on the board.

	@G.Cell 				// A=[G.Cell]-(BOARD_COLS+3) (top-left neighbor).
	D = M
	@BOARD_COLS+3
	AD = D - A				// D has a copy of A; I'll mark this as AD
	M = M + 1				// [AD]++

	AD = A + 1 				// [++AD]++ (top neighbor).
	M = M + 1

	AD = A + 1 				// [++AD]++ (top-right neighbor).
	M = M + 1

	@BOARD_COLS				// AD=D+BOARD_COLS (left neighbor).
	AD = D + A				// We save an instruction because of the copy of A.
	M = M + 1				// [A]++

	AD = A + 1 				// AD=A+2 (right neighbor).
	AD = A + 1
	M = M + 1				// [AD]++

	D = A 					
	@BOARD_COLS				// AD=D+BOARD_COLS (bottom-left neighbor).
	AD = D + A				// Again we save an instruction. At this point we don't
	M = M + 1				// need our copy of D, but we'll keep updating it for
							// clarity since it doesn't cost us anything.
	AD = A + 1 				// [++AD]++ (bottom neighbor).
	M = M + 1

	AD = A + 1 				// [++AD]++ (bottom-right neighbor).
	M = M + 1

// Whenever we have a loop that ends with a case statement, we can place a copy
// of the pre-case code at the end of each of the case branches, thus avoiding
// a jump back to the top of the loop. I refer to this optimization as
// Code Inception. In this case, there's only one case option that isn't either
// an exit or a jump back to the top of the loop, but this optimization saves
// us 2 instructions per live cell.

	@G.Cell					// D = [++G.Cell]
	AM = M + 1
	D = M

	@G.1.Next				// Shortcut for the most common case (Cell = 0)
	D ; JEQ

	@G.1.Case+1				// Index value into jump table (-1 value = end of board).
	A = A + D
	A = M 					// Load jump target from the table.
	0 ; JMP					// And we either loop, update neighbors, or quit.

(G.2)

	// Phase 2: add the counts in the guard cells to their respective border cells
	// on the opposite edge, and clear the guard cells. Here is a map of the guard
	// cells and the edge cells
	//
	// 0000 0001 ..... 0128 0129
	// 0130 0131 ..... 0258 0259
	//   .    .          .    .
	//   .    .          .    .
	// 8320 8321 ..... 8448 8449
	// 8450 8451 ..... 8578 8579
	//
	// The following code was auto-generated by tables-128.py. This is a case where
	// unrolling the loops is a big win because we don't have to do address arithmetic.

	@Board+0
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+129
	D = M
	M = 0
	@Board+8321
	M = M + D

	@Board+8450
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+8579
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+1
	D = M
	M = 0
	@Board+8321
	M = M + D

	@Board+8451
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+2
	D = M
	M = 0
	@Board+8322
	M = M + D

	@Board+8452
	D = M
	M = 0
	@Board+132
	M = M + D

	@Board+3
	D = M
	M = 0
	@Board+8323
	M = M + D

	@Board+8453
	D = M
	M = 0
	@Board+133
	M = M + D

	@Board+4
	D = M
	M = 0
	@Board+8324
	M = M + D

	@Board+8454
	D = M
	M = 0
	@Board+134
	M = M + D

	@Board+5
	D = M
	M = 0
	@Board+8325
	M = M + D

	@Board+8455
	D = M
	M = 0
	@Board+135
	M = M + D

	@Board+6
	D = M
	M = 0
	@Board+8326
	M = M + D

	@Board+8456
	D = M
	M = 0
	@Board+136
	M = M + D

	@Board+7
	D = M
	M = 0
	@Board+8327
	M = M + D

	@Board+8457
	D = M
	M = 0
	@Board+137
	M = M + D

	@Board+8
	D = M
	M = 0
	@Board+8328
	M = M + D

	@Board+8458
	D = M
	M = 0
	@Board+138
	M = M + D

	@Board+9
	D = M
	M = 0
	@Board+8329
	M = M + D

	@Board+8459
	D = M
	M = 0
	@Board+139
	M = M + D

	@Board+10
	D = M
	M = 0
	@Board+8330
	M = M + D

	@Board+8460
	D = M
	M = 0
	@Board+140
	M = M + D

	@Board+11
	D = M
	M = 0
	@Board+8331
	M = M + D

	@Board+8461
	D = M
	M = 0
	@Board+141
	M = M + D

	@Board+12
	D = M
	M = 0
	@Board+8332
	M = M + D

	@Board+8462
	D = M
	M = 0
	@Board+142
	M = M + D

	@Board+13
	D = M
	M = 0
	@Board+8333
	M = M + D

	@Board+8463
	D = M
	M = 0
	@Board+143
	M = M + D

	@Board+14
	D = M
	M = 0
	@Board+8334
	M = M + D

	@Board+8464
	D = M
	M = 0
	@Board+144
	M = M + D

	@Board+15
	D = M
	M = 0
	@Board+8335
	M = M + D

	@Board+8465
	D = M
	M = 0
	@Board+145
	M = M + D

	@Board+16
	D = M
	M = 0
	@Board+8336
	M = M + D

	@Board+8466
	D = M
	M = 0
	@Board+146
	M = M + D

	@Board+17
	D = M
	M = 0
	@Board+8337
	M = M + D

	@Board+8467
	D = M
	M = 0
	@Board+147
	M = M + D

	@Board+18
	D = M
	M = 0
	@Board+8338
	M = M + D

	@Board+8468
	D = M
	M = 0
	@Board+148
	M = M + D

	@Board+19
	D = M
	M = 0
	@Board+8339
	M = M + D

	@Board+8469
	D = M
	M = 0
	@Board+149
	M = M + D

	@Board+20
	D = M
	M = 0
	@Board+8340
	M = M + D

	@Board+8470
	D = M
	M = 0
	@Board+150
	M = M + D

	@Board+21
	D = M
	M = 0
	@Board+8341
	M = M + D

	@Board+8471
	D = M
	M = 0
	@Board+151
	M = M + D

	@Board+22
	D = M
	M = 0
	@Board+8342
	M = M + D

	@Board+8472
	D = M
	M = 0
	@Board+152
	M = M + D

	@Board+23
	D = M
	M = 0
	@Board+8343
	M = M + D

	@Board+8473
	D = M
	M = 0
	@Board+153
	M = M + D

	@Board+24
	D = M
	M = 0
	@Board+8344
	M = M + D

	@Board+8474
	D = M
	M = 0
	@Board+154
	M = M + D

	@Board+25
	D = M
	M = 0
	@Board+8345
	M = M + D

	@Board+8475
	D = M
	M = 0
	@Board+155
	M = M + D

	@Board+26
	D = M
	M = 0
	@Board+8346
	M = M + D

	@Board+8476
	D = M
	M = 0
	@Board+156
	M = M + D

	@Board+27
	D = M
	M = 0
	@Board+8347
	M = M + D

	@Board+8477
	D = M
	M = 0
	@Board+157
	M = M + D

	@Board+28
	D = M
	M = 0
	@Board+8348
	M = M + D

	@Board+8478
	D = M
	M = 0
	@Board+158
	M = M + D

	@Board+29
	D = M
	M = 0
	@Board+8349
	M = M + D

	@Board+8479
	D = M
	M = 0
	@Board+159
	M = M + D

	@Board+30
	D = M
	M = 0
	@Board+8350
	M = M + D

	@Board+8480
	D = M
	M = 0
	@Board+160
	M = M + D

	@Board+31
	D = M
	M = 0
	@Board+8351
	M = M + D

	@Board+8481
	D = M
	M = 0
	@Board+161
	M = M + D

	@Board+32
	D = M
	M = 0
	@Board+8352
	M = M + D

	@Board+8482
	D = M
	M = 0
	@Board+162
	M = M + D

	@Board+33
	D = M
	M = 0
	@Board+8353
	M = M + D

	@Board+8483
	D = M
	M = 0
	@Board+163
	M = M + D

	@Board+34
	D = M
	M = 0
	@Board+8354
	M = M + D

	@Board+8484
	D = M
	M = 0
	@Board+164
	M = M + D

	@Board+35
	D = M
	M = 0
	@Board+8355
	M = M + D

	@Board+8485
	D = M
	M = 0
	@Board+165
	M = M + D

	@Board+36
	D = M
	M = 0
	@Board+8356
	M = M + D

	@Board+8486
	D = M
	M = 0
	@Board+166
	M = M + D

	@Board+37
	D = M
	M = 0
	@Board+8357
	M = M + D

	@Board+8487
	D = M
	M = 0
	@Board+167
	M = M + D

	@Board+38
	D = M
	M = 0
	@Board+8358
	M = M + D

	@Board+8488
	D = M
	M = 0
	@Board+168
	M = M + D

	@Board+39
	D = M
	M = 0
	@Board+8359
	M = M + D

	@Board+8489
	D = M
	M = 0
	@Board+169
	M = M + D

	@Board+40
	D = M
	M = 0
	@Board+8360
	M = M + D

	@Board+8490
	D = M
	M = 0
	@Board+170
	M = M + D

	@Board+41
	D = M
	M = 0
	@Board+8361
	M = M + D

	@Board+8491
	D = M
	M = 0
	@Board+171
	M = M + D

	@Board+42
	D = M
	M = 0
	@Board+8362
	M = M + D

	@Board+8492
	D = M
	M = 0
	@Board+172
	M = M + D

	@Board+43
	D = M
	M = 0
	@Board+8363
	M = M + D

	@Board+8493
	D = M
	M = 0
	@Board+173
	M = M + D

	@Board+44
	D = M
	M = 0
	@Board+8364
	M = M + D

	@Board+8494
	D = M
	M = 0
	@Board+174
	M = M + D

	@Board+45
	D = M
	M = 0
	@Board+8365
	M = M + D

	@Board+8495
	D = M
	M = 0
	@Board+175
	M = M + D

	@Board+46
	D = M
	M = 0
	@Board+8366
	M = M + D

	@Board+8496
	D = M
	M = 0
	@Board+176
	M = M + D

	@Board+47
	D = M
	M = 0
	@Board+8367
	M = M + D

	@Board+8497
	D = M
	M = 0
	@Board+177
	M = M + D

	@Board+48
	D = M
	M = 0
	@Board+8368
	M = M + D

	@Board+8498
	D = M
	M = 0
	@Board+178
	M = M + D

	@Board+49
	D = M
	M = 0
	@Board+8369
	M = M + D

	@Board+8499
	D = M
	M = 0
	@Board+179
	M = M + D

	@Board+50
	D = M
	M = 0
	@Board+8370
	M = M + D

	@Board+8500
	D = M
	M = 0
	@Board+180
	M = M + D

	@Board+51
	D = M
	M = 0
	@Board+8371
	M = M + D

	@Board+8501
	D = M
	M = 0
	@Board+181
	M = M + D

	@Board+52
	D = M
	M = 0
	@Board+8372
	M = M + D

	@Board+8502
	D = M
	M = 0
	@Board+182
	M = M + D

	@Board+53
	D = M
	M = 0
	@Board+8373
	M = M + D

	@Board+8503
	D = M
	M = 0
	@Board+183
	M = M + D

	@Board+54
	D = M
	M = 0
	@Board+8374
	M = M + D

	@Board+8504
	D = M
	M = 0
	@Board+184
	M = M + D

	@Board+55
	D = M
	M = 0
	@Board+8375
	M = M + D

	@Board+8505
	D = M
	M = 0
	@Board+185
	M = M + D

	@Board+56
	D = M
	M = 0
	@Board+8376
	M = M + D

	@Board+8506
	D = M
	M = 0
	@Board+186
	M = M + D

	@Board+57
	D = M
	M = 0
	@Board+8377
	M = M + D

	@Board+8507
	D = M
	M = 0
	@Board+187
	M = M + D

	@Board+58
	D = M
	M = 0
	@Board+8378
	M = M + D

	@Board+8508
	D = M
	M = 0
	@Board+188
	M = M + D

	@Board+59
	D = M
	M = 0
	@Board+8379
	M = M + D

	@Board+8509
	D = M
	M = 0
	@Board+189
	M = M + D

	@Board+60
	D = M
	M = 0
	@Board+8380
	M = M + D

	@Board+8510
	D = M
	M = 0
	@Board+190
	M = M + D

	@Board+61
	D = M
	M = 0
	@Board+8381
	M = M + D

	@Board+8511
	D = M
	M = 0
	@Board+191
	M = M + D

	@Board+62
	D = M
	M = 0
	@Board+8382
	M = M + D

	@Board+8512
	D = M
	M = 0
	@Board+192
	M = M + D

	@Board+63
	D = M
	M = 0
	@Board+8383
	M = M + D

	@Board+8513
	D = M
	M = 0
	@Board+193
	M = M + D

	@Board+64
	D = M
	M = 0
	@Board+8384
	M = M + D

	@Board+8514
	D = M
	M = 0
	@Board+194
	M = M + D

	@Board+65
	D = M
	M = 0
	@Board+8385
	M = M + D

	@Board+8515
	D = M
	M = 0
	@Board+195
	M = M + D

	@Board+66
	D = M
	M = 0
	@Board+8386
	M = M + D

	@Board+8516
	D = M
	M = 0
	@Board+196
	M = M + D

	@Board+67
	D = M
	M = 0
	@Board+8387
	M = M + D

	@Board+8517
	D = M
	M = 0
	@Board+197
	M = M + D

	@Board+68
	D = M
	M = 0
	@Board+8388
	M = M + D

	@Board+8518
	D = M
	M = 0
	@Board+198
	M = M + D

	@Board+69
	D = M
	M = 0
	@Board+8389
	M = M + D

	@Board+8519
	D = M
	M = 0
	@Board+199
	M = M + D

	@Board+70
	D = M
	M = 0
	@Board+8390
	M = M + D

	@Board+8520
	D = M
	M = 0
	@Board+200
	M = M + D

	@Board+71
	D = M
	M = 0
	@Board+8391
	M = M + D

	@Board+8521
	D = M
	M = 0
	@Board+201
	M = M + D

	@Board+72
	D = M
	M = 0
	@Board+8392
	M = M + D

	@Board+8522
	D = M
	M = 0
	@Board+202
	M = M + D

	@Board+73
	D = M
	M = 0
	@Board+8393
	M = M + D

	@Board+8523
	D = M
	M = 0
	@Board+203
	M = M + D

	@Board+74
	D = M
	M = 0
	@Board+8394
	M = M + D

	@Board+8524
	D = M
	M = 0
	@Board+204
	M = M + D

	@Board+75
	D = M
	M = 0
	@Board+8395
	M = M + D

	@Board+8525
	D = M
	M = 0
	@Board+205
	M = M + D

	@Board+76
	D = M
	M = 0
	@Board+8396
	M = M + D

	@Board+8526
	D = M
	M = 0
	@Board+206
	M = M + D

	@Board+77
	D = M
	M = 0
	@Board+8397
	M = M + D

	@Board+8527
	D = M
	M = 0
	@Board+207
	M = M + D

	@Board+78
	D = M
	M = 0
	@Board+8398
	M = M + D

	@Board+8528
	D = M
	M = 0
	@Board+208
	M = M + D

	@Board+79
	D = M
	M = 0
	@Board+8399
	M = M + D

	@Board+8529
	D = M
	M = 0
	@Board+209
	M = M + D

	@Board+80
	D = M
	M = 0
	@Board+8400
	M = M + D

	@Board+8530
	D = M
	M = 0
	@Board+210
	M = M + D

	@Board+81
	D = M
	M = 0
	@Board+8401
	M = M + D

	@Board+8531
	D = M
	M = 0
	@Board+211
	M = M + D

	@Board+82
	D = M
	M = 0
	@Board+8402
	M = M + D

	@Board+8532
	D = M
	M = 0
	@Board+212
	M = M + D

	@Board+83
	D = M
	M = 0
	@Board+8403
	M = M + D

	@Board+8533
	D = M
	M = 0
	@Board+213
	M = M + D

	@Board+84
	D = M
	M = 0
	@Board+8404
	M = M + D

	@Board+8534
	D = M
	M = 0
	@Board+214
	M = M + D

	@Board+85
	D = M
	M = 0
	@Board+8405
	M = M + D

	@Board+8535
	D = M
	M = 0
	@Board+215
	M = M + D

	@Board+86
	D = M
	M = 0
	@Board+8406
	M = M + D

	@Board+8536
	D = M
	M = 0
	@Board+216
	M = M + D

	@Board+87
	D = M
	M = 0
	@Board+8407
	M = M + D

	@Board+8537
	D = M
	M = 0
	@Board+217
	M = M + D

	@Board+88
	D = M
	M = 0
	@Board+8408
	M = M + D

	@Board+8538
	D = M
	M = 0
	@Board+218
	M = M + D

	@Board+89
	D = M
	M = 0
	@Board+8409
	M = M + D

	@Board+8539
	D = M
	M = 0
	@Board+219
	M = M + D

	@Board+90
	D = M
	M = 0
	@Board+8410
	M = M + D

	@Board+8540
	D = M
	M = 0
	@Board+220
	M = M + D

	@Board+91
	D = M
	M = 0
	@Board+8411
	M = M + D

	@Board+8541
	D = M
	M = 0
	@Board+221
	M = M + D

	@Board+92
	D = M
	M = 0
	@Board+8412
	M = M + D

	@Board+8542
	D = M
	M = 0
	@Board+222
	M = M + D

	@Board+93
	D = M
	M = 0
	@Board+8413
	M = M + D

	@Board+8543
	D = M
	M = 0
	@Board+223
	M = M + D

	@Board+94
	D = M
	M = 0
	@Board+8414
	M = M + D

	@Board+8544
	D = M
	M = 0
	@Board+224
	M = M + D

	@Board+95
	D = M
	M = 0
	@Board+8415
	M = M + D

	@Board+8545
	D = M
	M = 0
	@Board+225
	M = M + D

	@Board+96
	D = M
	M = 0
	@Board+8416
	M = M + D

	@Board+8546
	D = M
	M = 0
	@Board+226
	M = M + D

	@Board+97
	D = M
	M = 0
	@Board+8417
	M = M + D

	@Board+8547
	D = M
	M = 0
	@Board+227
	M = M + D

	@Board+98
	D = M
	M = 0
	@Board+8418
	M = M + D

	@Board+8548
	D = M
	M = 0
	@Board+228
	M = M + D

	@Board+99
	D = M
	M = 0
	@Board+8419
	M = M + D

	@Board+8549
	D = M
	M = 0
	@Board+229
	M = M + D

	@Board+100
	D = M
	M = 0
	@Board+8420
	M = M + D

	@Board+8550
	D = M
	M = 0
	@Board+230
	M = M + D

	@Board+101
	D = M
	M = 0
	@Board+8421
	M = M + D

	@Board+8551
	D = M
	M = 0
	@Board+231
	M = M + D

	@Board+102
	D = M
	M = 0
	@Board+8422
	M = M + D

	@Board+8552
	D = M
	M = 0
	@Board+232
	M = M + D

	@Board+103
	D = M
	M = 0
	@Board+8423
	M = M + D

	@Board+8553
	D = M
	M = 0
	@Board+233
	M = M + D

	@Board+104
	D = M
	M = 0
	@Board+8424
	M = M + D

	@Board+8554
	D = M
	M = 0
	@Board+234
	M = M + D

	@Board+105
	D = M
	M = 0
	@Board+8425
	M = M + D

	@Board+8555
	D = M
	M = 0
	@Board+235
	M = M + D

	@Board+106
	D = M
	M = 0
	@Board+8426
	M = M + D

	@Board+8556
	D = M
	M = 0
	@Board+236
	M = M + D

	@Board+107
	D = M
	M = 0
	@Board+8427
	M = M + D

	@Board+8557
	D = M
	M = 0
	@Board+237
	M = M + D

	@Board+108
	D = M
	M = 0
	@Board+8428
	M = M + D

	@Board+8558
	D = M
	M = 0
	@Board+238
	M = M + D

	@Board+109
	D = M
	M = 0
	@Board+8429
	M = M + D

	@Board+8559
	D = M
	M = 0
	@Board+239
	M = M + D

	@Board+110
	D = M
	M = 0
	@Board+8430
	M = M + D

	@Board+8560
	D = M
	M = 0
	@Board+240
	M = M + D

	@Board+111
	D = M
	M = 0
	@Board+8431
	M = M + D

	@Board+8561
	D = M
	M = 0
	@Board+241
	M = M + D

	@Board+112
	D = M
	M = 0
	@Board+8432
	M = M + D

	@Board+8562
	D = M
	M = 0
	@Board+242
	M = M + D

	@Board+113
	D = M
	M = 0
	@Board+8433
	M = M + D

	@Board+8563
	D = M
	M = 0
	@Board+243
	M = M + D

	@Board+114
	D = M
	M = 0
	@Board+8434
	M = M + D

	@Board+8564
	D = M
	M = 0
	@Board+244
	M = M + D

	@Board+115
	D = M
	M = 0
	@Board+8435
	M = M + D

	@Board+8565
	D = M
	M = 0
	@Board+245
	M = M + D

	@Board+116
	D = M
	M = 0
	@Board+8436
	M = M + D

	@Board+8566
	D = M
	M = 0
	@Board+246
	M = M + D

	@Board+117
	D = M
	M = 0
	@Board+8437
	M = M + D

	@Board+8567
	D = M
	M = 0
	@Board+247
	M = M + D

	@Board+118
	D = M
	M = 0
	@Board+8438
	M = M + D

	@Board+8568
	D = M
	M = 0
	@Board+248
	M = M + D

	@Board+119
	D = M
	M = 0
	@Board+8439
	M = M + D

	@Board+8569
	D = M
	M = 0
	@Board+249
	M = M + D

	@Board+120
	D = M
	M = 0
	@Board+8440
	M = M + D

	@Board+8570
	D = M
	M = 0
	@Board+250
	M = M + D

	@Board+121
	D = M
	M = 0
	@Board+8441
	M = M + D

	@Board+8571
	D = M
	M = 0
	@Board+251
	M = M + D

	@Board+122
	D = M
	M = 0
	@Board+8442
	M = M + D

	@Board+8572
	D = M
	M = 0
	@Board+252
	M = M + D

	@Board+123
	D = M
	M = 0
	@Board+8443
	M = M + D

	@Board+8573
	D = M
	M = 0
	@Board+253
	M = M + D

	@Board+124
	D = M
	M = 0
	@Board+8444
	M = M + D

	@Board+8574
	D = M
	M = 0
	@Board+254
	M = M + D

	@Board+125
	D = M
	M = 0
	@Board+8445
	M = M + D

	@Board+8575
	D = M
	M = 0
	@Board+255
	M = M + D

	@Board+126
	D = M
	M = 0
	@Board+8446
	M = M + D

	@Board+8576
	D = M
	M = 0
	@Board+256
	M = M + D

	@Board+127
	D = M
	M = 0
	@Board+8447
	M = M + D

	@Board+8577
	D = M
	M = 0
	@Board+257
	M = M + D

	@Board+128
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+8578
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+130
	D = M
	M = 0
	@Board+258
	M = M + D

	@Board+259
	D = M
	M = 0
	@Board+131
	M = M + D

	@Board+260
	D = M
	M = 0
	@Board+388
	M = M + D

	@Board+389
	D = M
	M = 0
	@Board+261
	M = M + D

	@Board+390
	D = M
	M = 0
	@Board+518
	M = M + D

	@Board+519
	D = M
	M = 0
	@Board+391
	M = M + D

	@Board+520
	D = M
	M = 0
	@Board+648
	M = M + D

	@Board+649
	D = M
	M = 0
	@Board+521
	M = M + D

	@Board+650
	D = M
	M = 0
	@Board+778
	M = M + D

	@Board+779
	D = M
	M = 0
	@Board+651
	M = M + D

	@Board+780
	D = M
	M = 0
	@Board+908
	M = M + D

	@Board+909
	D = M
	M = 0
	@Board+781
	M = M + D

	@Board+910
	D = M
	M = 0
	@Board+1038
	M = M + D

	@Board+1039
	D = M
	M = 0
	@Board+911
	M = M + D

	@Board+1040
	D = M
	M = 0
	@Board+1168
	M = M + D

	@Board+1169
	D = M
	M = 0
	@Board+1041
	M = M + D

	@Board+1170
	D = M
	M = 0
	@Board+1298
	M = M + D

	@Board+1299
	D = M
	M = 0
	@Board+1171
	M = M + D

	@Board+1300
	D = M
	M = 0
	@Board+1428
	M = M + D

	@Board+1429
	D = M
	M = 0
	@Board+1301
	M = M + D

	@Board+1430
	D = M
	M = 0
	@Board+1558
	M = M + D

	@Board+1559
	D = M
	M = 0
	@Board+1431
	M = M + D

	@Board+1560
	D = M
	M = 0
	@Board+1688
	M = M + D

	@Board+1689
	D = M
	M = 0
	@Board+1561
	M = M + D

	@Board+1690
	D = M
	M = 0
	@Board+1818
	M = M + D

	@Board+1819
	D = M
	M = 0
	@Board+1691
	M = M + D

	@Board+1820
	D = M
	M = 0
	@Board+1948
	M = M + D

	@Board+1949
	D = M
	M = 0
	@Board+1821
	M = M + D

	@Board+1950
	D = M
	M = 0
	@Board+2078
	M = M + D

	@Board+2079
	D = M
	M = 0
	@Board+1951
	M = M + D

	@Board+2080
	D = M
	M = 0
	@Board+2208
	M = M + D

	@Board+2209
	D = M
	M = 0
	@Board+2081
	M = M + D

	@Board+2210
	D = M
	M = 0
	@Board+2338
	M = M + D

	@Board+2339
	D = M
	M = 0
	@Board+2211
	M = M + D

	@Board+2340
	D = M
	M = 0
	@Board+2468
	M = M + D

	@Board+2469
	D = M
	M = 0
	@Board+2341
	M = M + D

	@Board+2470
	D = M
	M = 0
	@Board+2598
	M = M + D

	@Board+2599
	D = M
	M = 0
	@Board+2471
	M = M + D

	@Board+2600
	D = M
	M = 0
	@Board+2728
	M = M + D

	@Board+2729
	D = M
	M = 0
	@Board+2601
	M = M + D

	@Board+2730
	D = M
	M = 0
	@Board+2858
	M = M + D

	@Board+2859
	D = M
	M = 0
	@Board+2731
	M = M + D

	@Board+2860
	D = M
	M = 0
	@Board+2988
	M = M + D

	@Board+2989
	D = M
	M = 0
	@Board+2861
	M = M + D

	@Board+2990
	D = M
	M = 0
	@Board+3118
	M = M + D

	@Board+3119
	D = M
	M = 0
	@Board+2991
	M = M + D

	@Board+3120
	D = M
	M = 0
	@Board+3248
	M = M + D

	@Board+3249
	D = M
	M = 0
	@Board+3121
	M = M + D

	@Board+3250
	D = M
	M = 0
	@Board+3378
	M = M + D

	@Board+3379
	D = M
	M = 0
	@Board+3251
	M = M + D

	@Board+3380
	D = M
	M = 0
	@Board+3508
	M = M + D

	@Board+3509
	D = M
	M = 0
	@Board+3381
	M = M + D

	@Board+3510
	D = M
	M = 0
	@Board+3638
	M = M + D

	@Board+3639
	D = M
	M = 0
	@Board+3511
	M = M + D

	@Board+3640
	D = M
	M = 0
	@Board+3768
	M = M + D

	@Board+3769
	D = M
	M = 0
	@Board+3641
	M = M + D

	@Board+3770
	D = M
	M = 0
	@Board+3898
	M = M + D

	@Board+3899
	D = M
	M = 0
	@Board+3771
	M = M + D

	@Board+3900
	D = M
	M = 0
	@Board+4028
	M = M + D

	@Board+4029
	D = M
	M = 0
	@Board+3901
	M = M + D

	@Board+4030
	D = M
	M = 0
	@Board+4158
	M = M + D

	@Board+4159
	D = M
	M = 0
	@Board+4031
	M = M + D

	@Board+4160
	D = M
	M = 0
	@Board+4288
	M = M + D

	@Board+4289
	D = M
	M = 0
	@Board+4161
	M = M + D

	@Board+4290
	D = M
	M = 0
	@Board+4418
	M = M + D

	@Board+4419
	D = M
	M = 0
	@Board+4291
	M = M + D

	@Board+4420
	D = M
	M = 0
	@Board+4548
	M = M + D

	@Board+4549
	D = M
	M = 0
	@Board+4421
	M = M + D

	@Board+4550
	D = M
	M = 0
	@Board+4678
	M = M + D

	@Board+4679
	D = M
	M = 0
	@Board+4551
	M = M + D

	@Board+4680
	D = M
	M = 0
	@Board+4808
	M = M + D

	@Board+4809
	D = M
	M = 0
	@Board+4681
	M = M + D

	@Board+4810
	D = M
	M = 0
	@Board+4938
	M = M + D

	@Board+4939
	D = M
	M = 0
	@Board+4811
	M = M + D

	@Board+4940
	D = M
	M = 0
	@Board+5068
	M = M + D

	@Board+5069
	D = M
	M = 0
	@Board+4941
	M = M + D

	@Board+5070
	D = M
	M = 0
	@Board+5198
	M = M + D

	@Board+5199
	D = M
	M = 0
	@Board+5071
	M = M + D

	@Board+5200
	D = M
	M = 0
	@Board+5328
	M = M + D

	@Board+5329
	D = M
	M = 0
	@Board+5201
	M = M + D

	@Board+5330
	D = M
	M = 0
	@Board+5458
	M = M + D

	@Board+5459
	D = M
	M = 0
	@Board+5331
	M = M + D

	@Board+5460
	D = M
	M = 0
	@Board+5588
	M = M + D

	@Board+5589
	D = M
	M = 0
	@Board+5461
	M = M + D

	@Board+5590
	D = M
	M = 0
	@Board+5718
	M = M + D

	@Board+5719
	D = M
	M = 0
	@Board+5591
	M = M + D

	@Board+5720
	D = M
	M = 0
	@Board+5848
	M = M + D

	@Board+5849
	D = M
	M = 0
	@Board+5721
	M = M + D

	@Board+5850
	D = M
	M = 0
	@Board+5978
	M = M + D

	@Board+5979
	D = M
	M = 0
	@Board+5851
	M = M + D

	@Board+5980
	D = M
	M = 0
	@Board+6108
	M = M + D

	@Board+6109
	D = M
	M = 0
	@Board+5981
	M = M + D

	@Board+6110
	D = M
	M = 0
	@Board+6238
	M = M + D

	@Board+6239
	D = M
	M = 0
	@Board+6111
	M = M + D

	@Board+6240
	D = M
	M = 0
	@Board+6368
	M = M + D

	@Board+6369
	D = M
	M = 0
	@Board+6241
	M = M + D

	@Board+6370
	D = M
	M = 0
	@Board+6498
	M = M + D

	@Board+6499
	D = M
	M = 0
	@Board+6371
	M = M + D

	@Board+6500
	D = M
	M = 0
	@Board+6628
	M = M + D

	@Board+6629
	D = M
	M = 0
	@Board+6501
	M = M + D

	@Board+6630
	D = M
	M = 0
	@Board+6758
	M = M + D

	@Board+6759
	D = M
	M = 0
	@Board+6631
	M = M + D

	@Board+6760
	D = M
	M = 0
	@Board+6888
	M = M + D

	@Board+6889
	D = M
	M = 0
	@Board+6761
	M = M + D

	@Board+6890
	D = M
	M = 0
	@Board+7018
	M = M + D

	@Board+7019
	D = M
	M = 0
	@Board+6891
	M = M + D

	@Board+7020
	D = M
	M = 0
	@Board+7148
	M = M + D

	@Board+7149
	D = M
	M = 0
	@Board+7021
	M = M + D

	@Board+7150
	D = M
	M = 0
	@Board+7278
	M = M + D

	@Board+7279
	D = M
	M = 0
	@Board+7151
	M = M + D

	@Board+7280
	D = M
	M = 0
	@Board+7408
	M = M + D

	@Board+7409
	D = M
	M = 0
	@Board+7281
	M = M + D

	@Board+7410
	D = M
	M = 0
	@Board+7538
	M = M + D

	@Board+7539
	D = M
	M = 0
	@Board+7411
	M = M + D

	@Board+7540
	D = M
	M = 0
	@Board+7668
	M = M + D

	@Board+7669
	D = M
	M = 0
	@Board+7541
	M = M + D

	@Board+7670
	D = M
	M = 0
	@Board+7798
	M = M + D

	@Board+7799
	D = M
	M = 0
	@Board+7671
	M = M + D

	@Board+7800
	D = M
	M = 0
	@Board+7928
	M = M + D

	@Board+7929
	D = M
	M = 0
	@Board+7801
	M = M + D

	@Board+7930
	D = M
	M = 0
	@Board+8058
	M = M + D

	@Board+8059
	D = M
	M = 0
	@Board+7931
	M = M + D

	@Board+8060
	D = M
	M = 0
	@Board+8188
	M = M + D

	@Board+8189
	D = M
	M = 0
	@Board+8061
	M = M + D

	@Board+8190
	D = M
	M = 0
	@Board+8318
	M = M + D

	@Board+8319
	D = M
	M = 0
	@Board+8191
	M = M + D

	@Board+8320
	D = M
	M = 0
	@Board+8448
	M = M + D

	@Board+8449
	D = M
	M = 0
	@Board+8321
	M = M + D

// Phase 3: use the previous generation state and the count of neighbors to update
// the cells. As with a previous phase, we use a jump table to implement a case
// statement. As with phase 1, we can use code inception to save a few instructions.

	@Board+BOARD_FIRST_CELL-1 // G.Cell = cell BEFORE the first possible active cell.
	D = A
	@G.Cell
	M = D
	
$G.3.Case(33) = Paint_Board, \		// Jump table for updating value of cell.
	G.3.Next, G.3.Dead, G.3.Dead, G.3.Live, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, \
	G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, \
	G.3.Dead, G.3.Dead, G.3.Live, G.3.Live, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, \
	G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead, G.3.Dead

(G.3.Next) 			// Repeat until we hit our special guard cell (value = -1)

	@G.Cell			// D = [++G.Cell]
	AM = M + 1
	D = M

	@G.3.Next		// Shortcut check for the most likely case (0 cell)
	D ; JEQ			// Same optimization case as in phase 1.

	@G.3.Case+1		// Index value into jump table (-1 value = end of board).
	A = A + D
	A = M 			// Load jump target from the table.
	0 ; JMP			// And we either loop, update neighbors, or quit.

(G.3.Dead)

	@G.Cell			// [G.Cell] = DEAD (depends on DEAD being 0)
	A = M
	M = 0

// Code Inception...

	@G.Cell			// D = [++G.Cell]
	AM = M + 1
	D = M

	@G.3.Next		// Shortcut check for the most likely case (0 cell)
	D ; JEQ			// Same optimization case as in phase 1.

	@G.3.Case+1		// Index value into jump table (-1 value = end of board).
	A = A + D
	A = M 			// Load jump target from the table.
	0 ; JMP			// And we either loop, update neighbors, or quit.

(G.3.Live)

	@ALIVE			// [G.Cell] = ALIVE
	D = A
	@G.Cell
	A = M
	M = D

// Code Inception...

	@G.Cell			// D = [++G.Cell]
	AM = M + 1
	D = M

	@G.3.Next		// Shortcut check for the most likely case (0 cell)
	D ; JEQ			// Same optimization case as in phase 1.

	@G.3.Case+1		// Index value into jump table (-1 value = end of board).
	A = A + D
	A = M 			// Load jump target from the table.
	0 ; JMP			// And we either loop, update neighbors, or quit.

// Paint_Board (PB) function; paints the current board onto the screen.

(Paint_Board)
(PB)

$PB.Screen.0		// Pointer to current screen word (row 0)
$PB.Screen.1		// We keep pointers to all 4 rows used
$PB.Screen.2		// when painting a cell in order to
$PB.Screen.3		// implement an efficiency hack.
$PB.Row   			// Current row in board.

	@SCREEN-1 							// PB.Screen.0 = Address of screen-1.
	D = A								// We will pre-increment these pointers
	@PB.Screen.0						// when used to save an instruction.
	M = D

	@SCREEN+SCREEN_WORDS_PER_ROW-1 		// PB.Screen.1 = next row down.
	D = A
	@PB.Screen.1
	M = D

	@SCREEN+(SCREEN_WORDS_PER_ROW*2)-1	// PB.Screen.2 = next row down.
	D = A								// Need to use parens because the
	@PB.Screen.2						// assembler doesn't understand
	M = D								// operator precedence.

	@SCREEN+(SCREEN_WORDS_PER_ROW*3)-1	// PB.Screen.3 = last of 4 rows.
	D = A
	@PB.Screen.3
	M = D

	@Board+BOARD_FIRST_CELL-1 	// PB.Cell = First real cell of the board
	D = A						// -1 because we are going to preincrement
	@PB.Cell					// it every time we read from it.
	M = D

	@BOARD_ROWS 			// PB.Row = 64 (number of rows we need to paint).
	D = A
	@PB.Row
	M = D

// Note to self: we can inline this call to @Paint_Board_Row  **TODO**

(PB.forRow) 				// Repeat Paint_Board_Row() while (--PB.Row > 0)

	@PB.forRow.Ret 			// D = Paint_Board_Row return address.
	D = A

	@SP 					// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Paint_Board_Row 		// Paint_Board_Row()
	0 ; JMP

(PB.forRow.Ret)

	@PB.Row 				// PB.Row,D = PB.Row - 1
	MD = M - 1
	
	@PB.forRow 				// Loop if PB.Row > 0
	D ; JGT

// Return to caller.

	@SP 					// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Paint_Board_Row(): Paint a single row (128 cells) onto the screen. We use an 4x4 matrix of pixels
// for each cell, so four cells fit into each word of pixels (16 pixels/word), and each row is
// replicated 4 times. On exit, PB.Screen.0 points to the first word of pixels for the next row of
// cells, and PB.Cell points to the first cell of the next row.

(Paint_Board_Row)
(PBR)

$PBR.Quad				// Quad cell paint loop count.

// Note to self: This loop could be unrolled.  **TODO**

	@BOARD_COLS/4 		// PBR.Quad = 32 (number of quads of cells we need to paint).
	D = A
	@PBR.Quad
	M = D

(PBR.forQuad) 			// repeat Paint_Board_Quad() while (--PBR.Quad > 0)

// Paint_Board_Quad(): paint a quad of cells [PB.Cell] ... [PB.Cell+3] onto the screen at word
// [PB.Screen]. Repeat for 4 screen rows, then update PB.Cell and PB.Screen for the next
// iteration.

(Paint_Board_Quad)
(PBQ)

$PBQ.Pixels				// Pixel representation of assembled group of 4 cells

// Conversion table for creating screen cell blocks. Since our ALIVE value is 0x0010 and each
// screen word contains 4 cells, we can shift and combine 4 cell values into a single value with
// a different bit for each cell (0000 0000 abcd 0000) and then use a table to convert this to
// the screen representation. Each value is duplicated 16 times so we can use the raw value.
// It'd be nice if HACK had a right-shift instruction but them's the breaks.
//
// Actual table is in 0000 0000 bacd 0000 order because of a tiny optimization (see below)

$PBQ.Blocks(256) = \
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \
	0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, \
	0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, 0x0F00, \
	0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, \

	0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, \
	0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, 0xF00F, \
	0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, \
	0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, 0xFF0F, \

	0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, 0x00F0, \
	0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, 0xF0F0, \
	0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, 0x0FF0, \
	0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, 0xFFF0, \

	0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, \
	0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, 0xF0FF, \
	0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF, \
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF

// Convert a set of 4 cells into a 16-bit pixel representation. Depends on ALIVE being 0x0010.
// and DEAD being 0x0000. The trick is that we shift and add the cell values to get an 8 bit
// value 0000 0000 abcd 0000, then do a table lookup to get the pixel representation.
//
// Tiny optimization. If we reshuffle the order to 0000 0000 bacd 0000 then we can remove
// a shift and replace another shift by a double-add.

	D = 0				// Initialize our lookup value.

	@PB.Cell			// A, PB.Cell = ++PB.Cell (address of first cell).
	AM = M + 1			// This lets us get value and move to next cell at same time.

	D = M 				// D = first cell "a" (0001 0000 or 0000 0000)

	@PB.Cell			// A, PB.Cell = ++PB.Cell (address of second cell "b").
	AM = M + 1

	D = D + M 			// D = 0000 0000 00ba 0000
	D = D + M 			// (Double-add puts b in the second bit position)

	A = D 				// D = D << 1 (0000 0000 0ba0 0000)
	D = D + A

	@PB.Cell			// A, PB.Cell = ++PB.Cell (address of third cell "c").
	AM = M + 1

	D = D + M 			// D = 0000 0000 0bac 0000
	A = D 				// D = D << 1 (0000 0000 bac0 0000)
	D = D + A

	@PB.Cell			// A, PB.Cell = ++PB.Cell (address of last cell "d").
	AM = M + 1

	D = D + M 			// D = 0000 0000 bacd 0000

	@PBQ.Blocks			// D = PBQ.Blocks[D] converts to pixel representation.
	A = A + D
	D = M

// Paint the pixels in D into 4 successive rows of the screen.
// Loop is unrolled for efficiency.

(PBQ.Paint)

	@PB.Screen.0 		// AM = ++PB.Screen.0 (location of first screen word to bash).
	AM = M + 1			// Combines getting pointer and incrementing it.
	M = D 				// Save the pixels

	@PB.Screen.1		// Repeat for the other 4 rows.
	AM = M + 1
	M = D

	@PB.Screen.2
	AM = M + 1
	M = D

	@PB.Screen.3
	AM = M + 1
	M = D

// PB.Screen.0-3 are now correctly set up for painting the next quad in the row,
// as is PB.Cell, so all we need to do is decrement our loop counter and
// repeat.

(PBQ.NextQuad)

	@PBR.Quad 			// PB.pair,D = PB.pair - 1
	MD = M - 1
	
	@PBR.forQuad		// Loop if PBR.Quad > 0
	D ; JGT

// Update PB.Cell and PB.Screen so they are correct for the next iteration.

	@PB.Cell 				// PB.Cell = PB.Cell + 2 (skips border cells).
	M = M + 1
	M = M + 1

	@SCREEN_WORDS_PER_ROW*3 // PB.Screen.0-3 = PB.Screen.0-3 + SCREEN_WORDS_PER_ROW*3
	D = A					// It's *3 instead of *4 because we've already incremented
	@PB.Screen.0			// the pointers all the way along one row of the screen
	M = M + D				// buffer.
	@PB.Screen.1
	M = M + D
	@PB.Screen.2
	M = M + D
	@PB.Screen.3
	M = M + D

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Load_Board (LB) function. Expects address of board data loader code in D. Clears the board, unpacks the data,
// and sets up the cells.

(Load_Board)
(LB)

$LB.Board			// Address of compressed board to load.
$LB.Cell			// Current cell of uncompressed board.
$LB.Row				// Current row of uncompressed board.

	@LB.Board       // Save the new board's address.
    M=D

// Clear the board by calling Clear_Board (CB) function

	@LB.Ret2 		// D = Clear board return address.
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Clear_Board 	// Clear_Board()
	0 ; JMP

(LB.Ret2)

	@Board+BOARD_FIRST_CELL
	D = A
	@LB.Cell
	M = D

	@BOARD_ROWS 	// LB.Row = number of rows we need to read.
	D = A
	@LB.Row
	M = D

(LB.forRow) 		// repeat Load_Board_Row() while (--LB.Row > 0)

	@LB.forRow.Ret 	// D = Load_Board_Row return address.
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Load_Board_Row // Load_Board_Row()
	0 ; JMP

(LB.forRow.Ret)

	@LB.Row 		// LB.Row,D = LB.Row - 1
	MD = M - 1
	
	@LB.forRow 		// Loop if LB.Row > 0
	D ; JGT

// Paint the board by jumping directly to Paint_Board()
// It will return to my caller.

	@Paint_Board
	0 ; JMP

// Load_Board_Row function. Load a single row from 8 words starting at LB.Board into
// 128 cells starting at LB.Cell, then move LB.Cell to the first cell of the next row
// and LB.Board to the first word of the next row of board information.

(Load_Board_Row)
(LBR)

$LBR.Word					// Current word index in compressed row	

	@BOARD_WORDS_PER_ROW 	// LBR.Word = 8 (for 128 col board)
	D = A
	@LBR.Word
	M = D

(LBR.forWord) 				// Repeat Load_Board_Word while (--LBR.Word > 0)

	@LBR.forWord.Ret 		// D = Load_Board_Row return address.
	D = A

	@SP 					// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Load_Board_Word		// Load_Board_Word()
	0 ; JMP

(LBR.forWord.Ret)

	@LBR.Word 				// LBR.Word,D = LBR.Word - 1
	MD = M - 1
	
	@LBR.forWord			// Loop if LB.Row > 0
	D ; JGT

	@LB.Cell 				// LB.Cell = LB.Cell + 2
	M = M + 1
	M = M + 1

// Return to caller.

	@SP 					// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Load_Board_Word(D): Use the 16 bits of [LB.Board] to set the next
// D cells starting at [LB.Cell]; increment LB.Board and LB.Cell.

(Load_Board_Word)
(LBW)

$LBW.Bits 				// Compressed bits being decoded.
$LBW.Count				// Current bit being processed.

	@16 				// LBW.Count = 16 (# of bits to transfer).
	D = A
	@LBW.Count
	M = D

	@LB.Board 			// LBW.Bits = [LB.Board]
	A = M
	D = M
	@LBW.Bits
	M = D

(LBW.forCell)			// Repeat [LB.Cell++] = Top bit of LBW.Bits while (--LBW.Count > 0)

	@LBW.Bits 			// D = LBW.Bits
	D = M

	M = D + M 			// LBW.Bits = LBW.Bits << 1 (but D still has original LBW.Bits).

	@LBW.forCell.Live	// If sign bit of D is set, set living cell, else dead cell.
	D ; JLT

(LBW.forCell.Dead)		// D = DEAD. Assumes DEAD = 0.

	D = 0
	@LBW.forCell.Set
	0 ; JMP

(LBW.forCell.Live)		// D = ALIVE

	@ALIVE
	D = A

(LBW.forCell.Set)

	@LB.Cell 			// [LB.Cell] = D
	A = M
	M = D

	D = A + 1 			// LB.Cell++
	@LB.Cell
	M = D

	@LBW.Count 			// LBW.Count,D = LBW.Count.i - 1
	MD = M - 1
	
	@LBW.forCell		// Loop if CB.i > 0
	D ; JGT

(LBW.incBoard)

	@LB.Board 			// LB.Board++ 
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board (SB) function. Expects address of buffer to be saved into in D. Packs the data in
// the current board into this buffer. As such, it is the inverse of Load_Board().

(Save_Board)
(SB)

$SB.Board			// Buffer in which to save the board.
$SB.Cell			// Current cell being saved.
$SB.Row				// Current row being saved.

	@SB.Board       // Save the new board's address.
    M=D

	@Board+BOARD_FIRST_CELL
	D = A
	@SB.Cell
	M = D

	@BOARD_ROWS 	// LB.Row = number of rows we need to read.
	D = A
	@SB.Row
	M = D

(SB.forRow) 		// repeat Save_Board_Row() while (--SB.Row > 0)

	@SB.forRow.Ret 	// D = Save_Board_Row return address.
	D = A

	@SP 			// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Save_Board_Row // Save_Board_Row()
	0 ; JMP

(SB.forRow.Ret)

	@SB.Row 		// SB.Row,D = SB.Row - 1
	MD = M - 1
	
	@SB.forRow 		// Loop if SB.Row > 0
	D ; JGT

// All done, so return to caller

	@SP 			// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board_Row function. Stores a single row of 8 words starting at SB.Board from
// 128 cells starting at SB.Cell, then move SB.Cell to the first cell of the next row
// and SB.Board to the first word of the next row of board information.

(Save_Board_Row)
(SBR)

$SBR.Word					// Address where packed word will be stored.

	@BOARD_WORDS_PER_ROW 	// SBR.Word = 8 (for 128 col board).
	D = A
	@SBR.Word
	M = D

(SBR.forWord) 				// repeat Save_Board_Word while (--SBR.Word > 0)

	@SBR.forWord.Ret 		// D = Save_Board_Row return address.
	D = A

	@SP 					// [SP--] = D (PUSH)
	A = M
	M = D
	@SP
	M = M - 1

	@Save_Board_Word		// Save_Board_Word()
	0 ; JMP

(SBR.forWord.Ret)

	@SBR.Word 				// LBR.Word,D = LBR.Word - 1
	MD = M - 1
	
	@SBR.forWord			// Loop if LB.Row > 0
	D ; JGT

	@SB.Cell 				// LB.Cell = LB.Cell + 2
	M = M + 1
	M = M + 1

// Return to caller.

	@SP 					// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Save_Board_Word(D): Store the next 16 cells starting at [SB.Cell] into
// [SB.Board]; increment SB.Board and SB.Cell.

(Save_Board_Word)
(SBW)

$SBW.Bits 				// Packed representation of 16 cells.
$SBW.Count				// Loop counter for the bits.

	@16 				// SBW.Count = 16 (# of bits to transfer).
	D = A
	@SBW.Count
	M = D

	@SBW.Bits			// SBW.Bits = 0 (we will accumulate them here).
	M = 0

(SBW.forCell)			// repeat shifting bits into SBW.Bits based on the cell values.

	@SBW.Bits 			// SBW.Bits << 1
	D = M
	M = M + D

	@SB.Cell			// D = [SB.Cell]
	A = M
	D = M

	@SBW.nextCell		// Skip to next if dead cell (0).
	D ; JEQ				// Assumes DEAD = 0.

	@SBW.Bits			// SBW.Bits++
	M = M + 1

(SBW.nextCell)

	@SB.Cell			// SB.Cell++
	M = M + 1

	@SBW.Count 			// SBW.Count,D = SBW.Count.i - 1
	MD = M - 1
	
	@SBW.forCell		// Loop if SBW.Count > 0
	D ; JGT

(SBW.storeBoard)

	@SBW.Bits			// [SB.Board] = SBW.Bits
	D = M
	@SB.Board
	A = M
	M = D

	@SB.Board			// SB.Board++
	M = M + 1

// Return to caller.

	@SP 				// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Clear_Board (CB) function. Clears all the cells including the border guard cells

(Clear_Board)
(CB)

$CB.Word			// Current word being cleared.

	@Board-1 		// CB.Word = Word before start of board.
	D = A
	@CB.Word
	M = D

(CB.Top)			// While [++CB.Word] != -1

	@CB.Word		// ++CB.Word
	AM = M + 1
	D = M			// D = [CB.Word] (keep old cell value).
	M = 0			// [CB.Word] = 0 (zeroes the cell).
	@CB.Top			// Loop if the value we just zapped was not -1.
	D ; JGE

	@BoardEndMark	// Fix up the end of board mark.
	M = -1			// Assumes END_M = -1.

// Return to caller.

	@SP 			// Jump to [++SP]
	AM = M + 1
	A = M
	0 ; JMP

// Stored boards. Boards are 128x64, so 8 words per row.

$Logo.png(*)=Boards/Logo.png
$Shimon.png(*)=Boards/Shimon.png
$Samples.png(*)=Boards/Samples.png
$NAND_11.png(*)=Boards/NAND_11.png
$NAND_10.png(*)=Boards/NAND_10.png
$NAND_01.png(*)=Boards/NAND_01.png
$NAND_00.png(*)=Boards/NAND_00.png
